<!DOCTYPE html>
<html lang="en" data-lt-installed="true" data-theme="default">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="appTitle">Game Backlog Tracker</title>
    <style>
        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --text-primary: #333;
            --text-secondary: #666;
            --bg-primary: white;
            --bg-secondary: rgba(255, 255, 255, 0.95);
            --border-color: #e0e0e0;
            --shadow-color: rgba(0,0,0,0.2);
            --playing-bg: #e8f5e9;
            --hold-bg: #fff8e1;
            --completed-bg: #f3e5f5;
            --abandoned-bg: #ffebee;
            --wishlist-bg: #e1f5fe;
            /* Status colors that don't change with theme */
            --status-playing: #4caf50;
            --status-hold: #ff9800;
            --status-abandoned: #f44336;
            --status-completed: #9c27b0;
            --status-none: #9e9e9e;
            --status-wishlist: #03a9f4;
            /* Warning colors for light mode */
            --warning-bg: rgba(255, 98, 0, 0.15);
            --warning-border: #ff6200;
            --warning-text: #ff6200;
        }

        [data-mode="dark"] {
            --text-primary: #f0f0f0;
            --text-secondary: #b0b0b0;
            --bg-primary: #2a2a2a;
            --bg-secondary: rgba(40, 40, 40, 0.95);
            --border-color: #505050;
            --shadow-color: rgba(0,0,0,0.7);
            --playing-bg: rgba(76, 175, 80, 0.2);
            --hold-bg: rgba(255, 152, 0, 0.2);
            --completed-bg: rgba(156, 39, 176, 0.2);
            --abandoned-bg: rgba(244, 67, 54, 0.2);
            --wishlist-bg: rgba(3, 169, 244, 0.2);
            /* Warning colors for dark mode */
            --warning-bg: rgba(255, 152, 0, 0.2);
            --warning-border: #ff9800;
            --warning-text: #ff9800;
        }
        
        [data-mode="dark"] input,
        [data-mode="dark"] select {
            background: #3a3a3a;
            color: #f0f0f0;
            border-color: #505050;
        }
        
        [data-mode="dark"] .editable-field:hover {
            background: #3a3a3a;
        }
        
        [data-mode="dark"] .editable-field:focus {
            background: #2a2a2a;
        }
        
        [data-mode="dark"] .summary-box {
            background: rgba(50, 50, 50, 0.5);
        }
        
        [data-mode="dark"] .tip-card,
        [data-mode="dark"] .suggestion-card {
            background: #3a3a3a;
        }

        [data-mode="dark"] .comment-modal,
        [data-mode="dark"] .friend-modal {
            background: #2a2a2a;
            border-color: #505050;
        }

        [data-mode="dark"] .friend-item,
        [data-mode="dark"] .warning-item {
            background: #3a3a3a;
            border-color: #505050;
        }

        [data-mode="dark"] .stats-card {
            background: #3a3a3a;
        }

        [data-theme="ocean"] {
            --bg-gradient-start: #00acc1;
            --bg-gradient-end: #5e35b1;
        }

        [data-theme="sunset"] {
            --bg-gradient-start: #ff6b6b;
            --bg-gradient-end: #ffd93d;
        }

        [data-theme="forest"] {
            --bg-gradient-start: #11998e;
            --bg-gradient-end: #38ef7d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .app-icon {
            font-size: 2.5em;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .icon-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 10px;
            display: none;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            z-index: 1000;
            box-shadow: 0 5px 15px var(--shadow-color);
            min-width: 320px;
        }

        .icon-dropdown.active {
            display: grid;
        }

        .icon-category {
            grid-column: span 6;
            font-size: 12px;
            color: var(--text-secondary);
            padding: 5px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 5px;
        }

        .icon-option {
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            text-align: center;
            font-size: 1.5em;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .icon-label {
            font-size: 8px;
            color: var(--text-secondary);
        }

        .icon-option:hover {
            background: var(--bg-secondary);
            transform: scale(1.1);
        }

        h1 {
            color: white;
            text-align: center;
            font-size: clamp(1.8em, 4vw, 2.5em);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            cursor: text;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        h1:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        h1.editing {
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        /* Warning Banner Section - Updated styling */
        .warning-banner {
            background: var(--warning-bg);
            color: var(--warning-text);
            padding: 12px 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            display: none;
            border: 2px solid var(--warning-border);
            font-weight: 600;
        }

        .warning-banner.active {
            display: block;
        }

        .warning-banner h3 {
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 700;
            color: var(--warning-text);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-messages {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .warning-message {
            background: var(--warning-bg);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 14px;
            color: var(--warning-text);
            font-weight: 600;
            border: 1px solid var(--warning-border);
        }

        /* Drag and Drop Visual Indicators */
        .drag-indicator {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            padding: 10px 20px;
            background: var(--bg-gradient-start);
            color: white;
            border-radius: 8px;
            font-weight: 600;
            display: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .drag-indicator.active {
            display: block;
        }

        /* Enhanced drag preview */
        .drag-preview {
            position: absolute;
            background: linear-gradient(90deg, var(--bg-gradient-start), var(--bg-gradient-end));
            height: 3px;
            border-radius: 2px;
            pointer-events: none;
            z-index: 1000;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Drag visual corner indicator - bottom left */
        tr.drag-target::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-bottom: 2px solid var(--bg-gradient-start);
            border-radius: 5px;
            pointer-events: none;
            z-index: 100;
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .section.collapsed {
            padding: 15px 20px;
            margin-bottom: 15px;
        }

        .section.dragging {
            opacity: 0.5;
            transform: scale(0.98);
            cursor: move;
        }

        .section.drag-over {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px var(--shadow-color);
            border-bottom: 2px dashed var(--bg-gradient-start);
        }

        .search-section {
            background: var(--bg-secondary);
            border-radius: 15px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            cursor: move;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: move;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .collapse-btn, .minimize-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            transition: transform 0.3s;
            padding: 5px;
        }

        .collapse-btn.collapsed {
            transform: rotate(-90deg);
        }

        .section-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .section-content.collapsed {
            max-height: 0;
            padding: 0;
            margin: 0;
            opacity: 0;
            overflow: hidden;
        }

        /* Friends System Styles */
        .friends-section {
            margin-bottom: 20px;
        }

        .friends-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .add-friend-form {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .friend-input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
        }

        .friends-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .friend-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .friend-item:hover {
            border-color: var(--bg-gradient-start);
            transform: translateY(-1px);
        }

        .friend-delete {
            cursor: pointer;
            color: #ff4757;
            font-weight: bold;
            margin-left: 5px;
        }

        /* Friend Modal */
        .friend-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 500px;
            z-index: 2000;
            box-shadow: 0 10px 30px var(--shadow-color);
            display: none;
        }

        .friend-modal.active {
            display: block;
        }

        .friend-games-list {
            max-height: 350px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .friend-game-item {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 10px;
            align-items: center;
            font-size: 14px;
        }

        .friend-game-item.playing-row {
            background: var(--playing-bg);
        }

        .friend-game-item.hold-row {
            background: var(--hold-bg);
        }

        .friend-game-item.abandoned-row {
            background: var(--abandoned-bg);
        }

        .friend-game-item.wishlist-row {
            background: var(--wishlist-bg);
        }

        .friend-game-item {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .friend-game-item:hover {
            background: rgba(102, 126, 234, 0.15) !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 3px solid var(--bg-gradient-start);
        }

        /* Warning System Styles */
        .warning-item {
            background: var(--bg-primary);
            border-left: 4px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .warning-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .warning-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .warning-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .warning-input-group label {
            flex: 1;
            font-size: 14px;
        }

        .warning-input-group input[type="number"] {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        .warning-checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Statistics Styles */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stats-card {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .stats-card h3 {
            color: var(--bg-gradient-start);
            margin-bottom: 15px;
            font-size: 16px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stats-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stats-filter-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stats-filter-group select,
        .stats-filter-group input {
            padding: 5px 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 12px;
        }

        /* Filter Section Styles */
        .filter-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .filter-section.active {
            display: block;
        }

        .filter-toggle {
            cursor: pointer;
            color: var(--bg-gradient-start);
            font-weight: 600;
            margin-bottom: 10px;
            display: inline-block;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-item label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Timeline improvements */
        .timeline-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .timeline-filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .timeline-filter-group label {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .timeline-limit-input {
            width: 60px;
            padding: 5px 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        .timeline-container {
            margin-top: 20px;
            padding: 20px;
            background: var(--bg-primary);
            border-radius: 10px;
            overflow-x: auto;
        }

        .timeline {
            position: relative;
            padding: 60px 0 40px;
            min-height: 140px;
        }

        .timeline-line {
            position: absolute;
            top: 70%;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--border-color);
        }

        .timeline-item {
            position: absolute;
            background: var(--bg-gradient-start);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 11px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 1;
            top: 40%;
            transform: translateX(-50%);
        }

        /* Timeline status colors */
        .timeline-item.status-playing {
            background: var(--status-playing);
        }

        .timeline-item.status-hold {
            background: var(--status-hold);
        }

        .timeline-item.status-none {
            background: var(--status-none);
        }

        .timeline-item.status-abandoned {
            background: var(--status-abandoned);
        }

        .timeline-item:hover {
            cursor: pointer;
        }

        .timeline-date {
            position: absolute;
            top: 75%;
            transform: translateX(-50%);
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 15px;
        }

        .timeline-infinite-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px dashed var(--border-color);
        }

        .timeline-infinite-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .timeline-infinite-games {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .timeline-infinite-item {
            background: var(--bg-gradient-end);
            color: white;
            padding: 6px 12px;
            border-radius: 5px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .timeline-infinite-item:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .timeline-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
            white-space: normal;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .timeline-tooltip.active {
            display: block;
        }

        .timeline-empty-message {
            text-align: center;
            color: var(--text-secondary);
            padding: 40px 10px 10px;
        }

        /* Blinking outline using box-shadow - no layout changes */
        tr.highlight-row {
            animation: outlineBlink 6s ease-in-out;
        }
        
        @keyframes outlineBlink {
            0%, 25%, 50%, 75%, 100% { 
                box-shadow: inset 0 0 0 0 rgba(135, 206, 235, 0);
            }
            12%, 37%, 62% {
                box-shadow: inset 0 0 0 4px rgba(135, 206, 235, 1);
            }
        }

        /* Game Picker Section */
        .game-picker-card {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .picker-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .picker-filter-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .picker-filter-item input[type="checkbox"] {
            margin: 0;
        }

        .picker-filter-item label {
            font-size: 14px;
            cursor: pointer;
        }

        /* Tooltip styles */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            max-width: 300px;
            word-wrap: break-word;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .tooltip.active {
            display: block;
        }

        /* Enhanced game title hover */
        .game-title, 
        .editable-field[value] {
            transition: all 0.2s ease;
            cursor: text;
        }

        td input.game-title:hover,
        td .editable-field:hover {
            background: rgba(102, 126, 234, 0.15) !important;
        }

        /* Specific enhanced hover for game names */
        td input.game-title:hover {
            background: rgba(102, 126, 234, 0.15) !important;
        }

        /* Adjusted field sizes */
        .form-grid {
            display: grid;
            grid-template-columns: 35px minmax(280px, 3.5fr) 40px 40px 40px 130px 35px 35px 110px 85px 85px 60px 60px 80px 90px minmax(100px, 1.2fr) 100px 80px;
            gap: 8px;
            align-items: center;
            margin-bottom: 15px;
        }

        .form-labels {
            display: grid;
            grid-template-columns: 35px minmax(280px, 3.5fr) 40px 40px 40px 130px 35px 35px 110px 85px 85px 60px 60px 80px 90px minmax(100px, 1.2fr) 100px 80px;
            gap: 8px;
            margin-bottom: 10px;
        }

        /* Smaller time fields */
        .length-cell {
            width: 100%;
            font-size: 11px;
            padding: 5px 4px;
        }

        .theme-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 5px 15px var(--shadow-color);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .theme-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .theme-btn:hover {
            transform: scale(1.1);
        }

        .theme-btn.active {
            border-color: white;
            box-shadow: 0 0 0 3px rgba(255,255,255,0.3);
        }

        .theme-default { background: linear-gradient(135deg, #667eea, #764ba2); }
        .theme-ocean { background: linear-gradient(135deg, #00acc1, #5e35b1); }
        .theme-sunset { background: linear-gradient(135deg, #ff6b6b, #ffd93d); }
        .theme-forest { background: linear-gradient(135deg, #11998e, #38ef7d); }

        .mode-toggle {
            background: var(--text-primary);
            color: var(--bg-primary);
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .controls-section {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 250px;
            padding: 12px 20px;
            font-size: 14px;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--bg-gradient-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .control-btn {
            padding: 10px 20px;
            background: var(--bg-primary);
            border: 2px solid var(--bg-gradient-start);
            color: var(--bg-gradient-start);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: var(--bg-gradient-start);
            color: white;
            transform: translateY(-2px);
        }

        .control-btn.unsaved {
            border-color: #ff9800;
            background: #fff3e0;
            animation: pulse 2s infinite;
        }

        .last-saved {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 5px 10px;
            background: var(--bg-secondary);
            border-radius: 5px;
        }

        .suggestion-result {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-top: 10px;
            text-align: center;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .suggested-game {
            font-size: 18px;
            font-weight: bold;
            color: var(--bg-gradient-start);
            margin-bottom: 5px;
        }

        .suggested-info {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .generate-btn {
            width: 100%;
            padding: 10px;
            background: var(--bg-gradient-start);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .generate-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .time-calculator-section {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .time-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time-input-group label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .time-input-group input {
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            width: 80px;
            font-size: 14px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .time-calculation {
            flex: 1;
            padding: 15px;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: white;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
        }

        .time-details {
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.9;
        }

        .form-label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 11px;
            text-align: center;
        }

        .status-dropdown {
            padding: 7px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px;
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            width: 100%;
        }

        .status-dropdown:focus {
            outline: none;
            border-color: var(--bg-gradient-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .coop-checkbox,
        .infinity-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            color: #999;
            transition: all 0.2s;
            background: var(--bg-primary);
            user-select: none;
        }

        .coop-checkbox.checked,
        .infinity-checkbox.checked {
            background: var(--bg-gradient-start);
            border-color: var(--bg-gradient-start);
            color: white;
            font-size: 20px;
        }

        .coop-checkbox:hover,
        .infinity-checkbox:hover {
            transform: scale(1.1);
            border-color: var(--bg-gradient-start);
            color: var(--bg-gradient-start);
        }
        
        .status-select {
            padding: 6px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px;
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 100%;
            cursor: pointer;
        }
        
        .status-select:focus {
            outline: none;
            border-color: var(--bg-gradient-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .coop-cell,
        .infinity-cell {
            text-align: center;
        }
        
        .coop-cell.active,
        .infinity-cell.active {
            font-weight: bold;
        }

        .completed-date-field {
            font-size: 11px;
            padding: 5px 6px;
            width: 100%;
        }

        input, select, button {
            padding: 7px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px;
            transition: all 0.3s ease;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--bg-gradient-start);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            caret-color: var(--bg-gradient-start);
        }

        .comment-wrapper {
            position: relative;
        }

        .comment-input {
            width: 100%;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .comment-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 400px;
            z-index: 2000;
            box-shadow: 0 10px 30px var(--shadow-color);
            display: none;
        }

        .comment-modal.active {
            display: block;
        }

        .comment-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .comment-modal-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        .comment-modal-close {
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .comment-modal-close:hover {
            color: var(--text-primary);
        }

        .comment-modal-content {
            overflow-y: auto;
            max-height: 250px;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .comment-modal-content.editable {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }

        .comment-modal-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .comment-modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .comment-modal-btn.primary {
            background: var(--bg-gradient-start);
            color: white;
            border: none;
        }

        .comment-modal-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .comment-modal-btn.secondary {
            background: transparent;
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .comment-modal-btn.secondary:hover {
            background: var(--bg-secondary);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .modal-overlay.active {
            display: block;
        }

        .add-btn {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 12px 24px;
            margin-top: 10px;
        }

        .add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: white;
            padding: 10px 6px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 11px;
        }

        td {
            padding: 6px;
            border-bottom: 1px solid var(--border-color);
            font-size: 12px;
            position: relative;
        }

        tr {
            transition: all 0.3s ease;
            background: var(--bg-primary);
            position: relative;
        }

        tr:hover {
            background: var(--bg-secondary);
        }

        tr.playing-row {
            background: var(--playing-bg);
        }

        tr.hold-row {
            background: var(--hold-bg);
        }

        tr.abandoned-row {
            background: var(--abandoned-bg);
        }

        tr.wishlist-row {
            background: var(--wishlist-bg);
        }

        tr.dragging {
            opacity: 0.5;
            background: #e8ebff;
        }

        .drag-handle {
            cursor: move;
            color: var(--text-secondary);
            font-size: 16px;
            padding: 0 6px;
            user-select: none;
        }

        .drag-handle:hover {
            color: var(--bg-gradient-start);
        }

        .status-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            margin: 0 auto;
        }

        .status-icon:hover {
            transform: scale(1.1);
        }

        .status-none {
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .status-playing {
            background: #4caf50;
            color: white;
        }

        .status-hold {
            background: #ff9800;
            color: white;
        }

        .status-completed {
            background: #9c27b0;
            color: white;
        }

        .status-abandoned {
            background: #f44336;
            color: white;
        }

        .status-wishlist {
            background: #03a9f4;
            color: white;
        }

        .checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--bg-gradient-start);
        }
        
        .checkbox[type="checkbox"]:checked::before {
            accent-color: var(--bg-gradient-start);
        }

        .editable-field {
            background: transparent;
            border: 1px solid transparent;
            padding: 4px 6px;
            border-radius: 4px;
            width: 100%;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .editable-field:hover {
            background: var(--bg-secondary);
        }

        .editable-field:focus {
            background: var(--bg-primary);
            border-color: var(--bg-gradient-start);
            outline: none;
        }

        .value-cell {
            font-weight: 600;
            text-align: center;
        }

        .value-high {
            color: #4caf50;
        }

        .value-medium {
            color: #ff9800;
        }

        .value-low {
            color: #f44336;
        }

        .delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        .delete-btn:hover {
            background: #ff3838;
            transform: translateY(-2px);
        }

        .difficulty-select {
            padding: 7px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px;
            background: var(--bg-primary);
            color: var(--text-primary);
            width: 100%;
        }
        
        .difficulty-select.easy {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .difficulty-select.medium {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }
        
        .difficulty-select.hard {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .hdr-buttons {
            display: flex;
            gap: 2px;
            justify-content: center;
        }

        .hdr-btn {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-color);
            background: var(--bg-primary);
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .hdr-btn:hover {
            border-color: var(--bg-gradient-start);
            transform: scale(1.1);
        }

        .hdr-btn.active {
            background: var(--bg-gradient-start);
            border-color: var(--bg-gradient-start);
            color: white;
        }

        .star-rating {
            display: flex;
            gap: 2px;
            justify-content: center;
        }

        .star {
            cursor: pointer;
            color: var(--border-color);
            font-size: 16px;
            transition: all 0.2s;
        }

        .star:hover {
            transform: scale(1.2);
        }

        .star.filled {
            color: #ffd700;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .summary-box {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .summary-item {
            text-align: center;
        }

        .summary-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .summary-value {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .tips-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .tip-card {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid var(--bg-gradient-start);
        }

        .tip-title {
            font-weight: 600;
            color: var(--bg-gradient-start);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tip-content {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.5;
        }

        h2 {
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: normal;
        }

        #fileInput {
            display: none;
        }

        @media (max-width: 1200px) {
            .form-grid, .form-labels {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .form-labels {
                display: none;
            }
            
            .form-grid > * {
                width: 100%;
            }

            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }

            .theme-controls {
                position: static;
                margin-bottom: 20px;
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            .controls-section {
                flex-direction: column;
            }

            .search-input {
                width: 100%;
            }

            .time-calculator-section {
                flex-direction: column;
            }

            .tips-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="theme-controls">
        <button class="theme-btn theme-default active" onclick="setTheme('default')"></button>
        <button class="theme-btn theme-ocean" onclick="setTheme('ocean')"></button>
        <button class="theme-btn theme-sunset" onclick="setTheme('sunset')"></button>
        <button class="theme-btn theme-forest" onclick="setTheme('forest')"></button>
        <button class="mode-toggle" onclick="toggleMode()">🌙</button>
    </div>

    <div class="container" id="sectionsContainer">
        <div class="app-header">
            <div class="app-icon" id="appIcon" onclick="toggleIconDropdown()">
                🎮
                <div class="icon-dropdown" id="iconDropdown">
                    <div class="icon-category">Gaming</div>
                    <div class="icon-option" onclick="setIcon('🎮')">
                        <span>🎮</span>
                        <span class="icon-label">Controller</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🎯')">
                        <span>🎯</span>
                        <span class="icon-label">Target</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🕹️')">
                        <span>🕹️</span>
                        <span class="icon-label">Joystick</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('⚔️')">
                        <span>⚔️</span>
                        <span class="icon-label">Swords</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🏆')">
                        <span>🏆</span>
                        <span class="icon-label">Trophy</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🎲')">
                        <span>🎲</span>
                        <span class="icon-label">Dice</span>
                    </div>
                    <div class="icon-category">Console</div>
                    <div class="icon-option" onclick="setIcon('💻')">
                        <span>💻</span>
                        <span class="icon-label">PC</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🖥️')">
                        <span>🖥️</span>
                        <span class="icon-label">Desktop</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🥽')">
                        <span>🥽</span>
                        <span class="icon-label">VR</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('📱')">
                        <span>📱</span>
                        <span class="icon-label">Mobile</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('👾')">
                        <span>👾</span>
                        <span class="icon-label">Retro</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🚀')">
                        <span>🚀</span>
                        <span class="icon-label">Space</span>
                    </div>
                    <div class="icon-category">Goals</div>
                    <div class="icon-option" onclick="setIcon('🎯')">
                        <span>🎯</span>
                        <span class="icon-label">Focus</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🏁')">
                        <span>🏁</span>
                        <span class="icon-label">Finish</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('⭐')">
                        <span>⭐</span>
                        <span class="icon-label">Star</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('🔥')">
                        <span>🔥</span>
                        <span class="icon-label">Hot</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('⏰')">
                        <span>⏰</span>
                        <span class="icon-label">Time</span>
                    </div>
                    <div class="icon-option" onclick="setIcon('📊')">
                        <span>📊</span>
                        <span class="icon-label">Stats</span>
                    </div>
                </div>
            </div>
            <h1 id="appTitleText" contenteditable="true" onblur="saveTitle()" onfocus="this.classList.add('editing')" onkeypress="if(event.keyCode==13){this.blur();return false;}">Game Backlog Tracker</h1>
        </div>
        
        <div class="section" draggable="true" data-section-id="controls">
            <div class="section-header">
                <h2>Controls</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="controls-section">
                    <button class="control-btn" onclick="exportToCSV()">📤 Export CSV</button>
                    <button class="control-btn" onclick="document.getElementById('fileInput').click()">📥 Import CSV</button>
                    <button class="control-btn unsaved" id="saveBtn" onclick="saveHTML()">💾 Save HTML *</button>
                    <span class="last-saved" id="lastSaved">Last saved: Never</span>
                    <input type="file" id="fileInput" accept=".csv" onchange="importCSV(event)">
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="add-game">
            <div class="section-header">
                <h2>Add New Game</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="form-labels">
                    <div class="form-label"></div>
                    <div class="form-label">Name</div>
                    <div class="form-label">Main</div>
                    <div class="form-label">Extra</div>
                    <div class="form-label">100%</div>
                    <div class="form-label">Status</div>
                    <div class="form-label">♾️</div>
                    <div class="form-label">🤝</div>
                    <div class="form-label">Difficulty</div>
                    <div class="form-label">Platform</div>
                    <div class="form-label">Genre</div>
                    <div class="form-label">Cost (€)</div>
                    <div class="form-label">Hours</div>
                    <div class="form-label">HDR</div>
                    <div class="form-label">Rating</div>
                    <div class="form-label">Playing With</div>
                    <div class="form-label">Comment</div>
                    <div class="form-label"></div>
                </div>
                <div class="form-grid">
                    <div></div>
                    <input type="text" id="gameName" placeholder="Game name..." class="has-tooltip" 
                           onmouseover="showTooltip(event, 'Enter the name of the game')" 
                           onmouseout="hideTooltip()">
                    <input type="text" id="lengthMain" placeholder="25" class="length-cell">
                    <input type="text" id="lengthExtra" placeholder="40" class="length-cell">
                    <input type="text" id="lengthComplete" placeholder="80" class="length-cell">
                    <select id="statusDropdown" class="status-dropdown">
                        <option value="none">○ None</option>
                        <option value="playing">▶ Playing</option>
                        <option value="hold">⏸ On Hold</option>
                        <option value="abandoned">❌ Abandoned</option>
                        <option value="wishlist">💫 Wishlist</option>
                    </select>
                    <div class="infinity-checkbox" id="replayableBtn" onclick="toggleReplayable()" title="Infinitely Replayable">
                        ♾️
                    </div>
                    <div class="coop-checkbox" id="coopBtn" onclick="toggleCoop()" title="Co-op Game">
                        🤝
                    </div>
                    <select id="difficulty" class="difficulty-select" onchange="updateDifficultyStyle(this)">
                        <option value="Unknown">Unknown</option>
                        <option value="Easy">Easy</option>
                        <option value="Medium">Medium</option>
                        <option value="Hard">Hard</option>
                    </select>
                    <select id="platform">
                        <option value="">Select...</option>
                        <option value="PC">PC</option>
                        <option value="Nintendo Switch">Nintendo Switch</option>
                        <option value="Quest 3">Quest 3</option>
                        <option value="Phone">Phone</option>
                        <option value="PS5">PS5</option>
                        <option value="PS4">PS4</option>
                        <option value="Xbox Series X">Xbox Series X</option>
                        <option value="Xbox One">Xbox One</option>
                    </select>
                    <select id="genre"><option value="">Select...</option></select>
                    <input type="number" id="cost" placeholder="59.99" step="0.01" min="0">
                    <input type="number" id="playedHours" placeholder="0" step="0.1" min="0">
                    <div class="hdr-buttons">
                        <button class="hdr-btn active" onclick="setHDR(this, 'None')" title="None">✕</button>
                        <button class="hdr-btn" onclick="setHDR(this, 'Native')" title="Native HDR">★</button>
                        <button class="hdr-btn" onclick="setHDR(this, 'AutoHDR')" title="Auto HDR">◐</button>
                    </div>
                    <div class="star-rating" id="addRating">
                        <span class="star" onclick="setRating('add', 1)">★</span>
                        <span class="star" onclick="setRating('add', 2)">★</span>
                        <span class="star" onclick="setRating('add', 3)">★</span>
                        <span class="star" onclick="setRating('add', 4)">★</span>
                        <span class="star" onclick="setRating('add', 5)">★</span>
                    </div>
                    <div class="playing-with-field">
                        <input type="text" id="playingWith" class="comment-input" placeholder="Solo" onclick="openPlayingWithModal('add')" 
                               onmouseover="showTooltip(event, this.value || 'Solo')" 
                               onmouseout="hideTooltip()" readonly>
                    </div>
                    <input type="text" id="comment" class="comment-input" placeholder="Notes..." onclick="openCommentModal('add', this.value)" readonly>
                    <div></div>
                </div>
                <button class="add-btn" onclick="addGame()">Add Game</button>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="friends">
            <div class="section-header">
                <h2>👥 Friends</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="friends-section">
                    <div class="add-friend-form">
                        <input type="text" id="friendName" class="friend-input" placeholder="Add friend name...">
                        <button class="control-btn" onclick="addFriend()">Add Friend</button>
                    </div>
                    <div class="friends-list" id="friendsList"></div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="suggestions">
            <div class="section-header">
                <h2>🎲 Game Picker</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="game-picker-card">
                    <div class="picker-filters">
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerPlaying" checked>
                            <label for="pickerPlaying">Playing</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerHold" checked>
                            <label for="pickerHold">On Hold</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerNone" checked>
                            <label for="pickerNone">Not Started</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerAbandoned">
                            <label for="pickerAbandoned">Abandoned</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerCoop">
                            <label for="pickerCoop">Co-op Only</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerInfinite">
                            <label for="pickerInfinite">Infinite Only</label>
                        </div>
                        <div class="picker-filter-item">
                            <input type="checkbox" id="pickerWeekend">
                            <label for="pickerWeekend">Weekend Games</label>
                        </div>
                    </div>
                    <button class="generate-btn" onclick="pickGame()">Pick Random Game</button>
                    <div class="suggestion-result" id="pickerResult">
                        Click to pick a random game
                    </div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="time-calculator">
            <div class="section-header">
                <h2>Time Calculator</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="time-calculator-section">
                    <div class="time-input-group">
                        <label for="weekdayTime">Weekday hours/day:</label>
                        <input type="number" id="weekdayTime" placeholder="2" step="0.5" min="0" onchange="updateTimeCalculation()">
                    </div>
                    <div class="time-input-group">
                        <label for="weekendTime">Weekend hours/day:</label>
                        <input type="number" id="weekendTime" placeholder="4" step="0.5" min="0" onchange="updateTimeCalculation()">
                    </div>
                    <div class="time-calculation" id="timeCalculation">
                        <div>Enter your gaming hours to see completion estimate</div>
                    </div>
                </div>
                <div class="timeline-container">
                    <h3 style="margin-bottom: 10px;">Game Timeline</h3>
                    <div class="timeline-controls">
                        <div class="timeline-filter-group">
                            <label><input type="checkbox" id="timelinePlaying" checked onchange="updateTimeline()"> Playing</label>
                            <label><input type="checkbox" id="timelineHold" checked onchange="updateTimeline()"> On Hold</label>
                            <label><input type="checkbox" id="timelineNone" checked onchange="updateTimeline()"> Not Started</label>
                            <label><input type="checkbox" id="timelineInfinite" onchange="updateTimeline()"> Infinitely Replayable</label>
                            <label><input type="checkbox" id="timelineCoop" onchange="updateTimeline()"> Co-op</label>
                        </div>
                        <div>
                            Show next <input type="number" class="timeline-limit-input" id="timelineLimit" value="10" min="1" max="50" onchange="updateTimeline()"> games
                        </div>
                    </div>
                    <div class="timeline" id="gameTimeline"></div>
                </div>
            </div>
        </div>

        <div class="search-section" draggable="true" data-section-id="search">
            <input type="text" class="search-input" id="searchInput" placeholder="🔍 Search your games...">
        </div>

        <div class="section" draggable="true" data-section-id="pile-of-shame">
            <div class="section-header">
                <h2>
                    📚 Pile of Shame 
                    <span class="badge" id="shameCount">0</span>
                </h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <!-- Warning Banner moved inside section content -->
                <div class="warning-banner" id="warningBanner">
                    <h3>⚠️ Active Warnings</h3>
                    <div class="warning-messages" id="warningMessages"></div>
                </div>
                
                <div class="filter-toggle" onclick="toggleFilters('shame')">⚙️ Filters</div>
                <div class="filter-section" id="shameFilters">
                    <div class="filter-grid">
                        <div class="filter-item">
                            <label>Playtime (hours)</label>
                            <input type="number" id="shameFilterPlaytime" placeholder="Any" onchange="applyFilters('shame')">
                        </div>
                        <div class="filter-item">
                            <label>Completion Type</label>
                            <select id="shameFilterCompletion" onchange="applyFilters('shame')">
                                <option value="">Any</option>
                                <option value="main">Main</option>
                                <option value="extra">Extra</option>
                                <option value="100">100%</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Status</label>
                            <select id="shameFilterStatus" onchange="applyFilters('shame')">
                                <option value="">Any</option>
                                <option value="none">None</option>
                                <option value="playing">Playing</option>
                                <option value="hold">On Hold</option>
                                <option value="abandoned">Abandoned</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Difficulty</label>
                            <select id="shameFilterDifficulty" onchange="applyFilters('shame')">
                                <option value="">Any</option>
                                <option value="Easy">Easy</option>
                                <option value="Medium">Medium</option>
                                <option value="Hard">Hard</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Genre</label>
                            <select id="shameFilterGenre" onchange="applyFilters('shame')">
                                <option value="">Any</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Properties</label>
                            <label><input type="checkbox" id="shameFilterInfinite" onchange="applyFilters('shame')"> Infinitely Replayable</label>
                            <label><input type="checkbox" id="shameFilterCoop" onchange="applyFilters('shame')"> Co-op</label>
                        </div>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="shameTable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>✓</th>
                                <th>Game</th>
                                <th>Main</th>
                                <th>Extra</th>
                                <th>100%</th>
                                <th>Status</th>
                                <th>♾️</th>
                                <th>🤝</th>
                                <th>Difficulty</th>
                                <th>Platform</th>
                                <th>Genre</th>
                                <th>Cost (€)</th>
                                <th>Played (h)</th>
                                <th>€/h</th>
                                <th>HDR</th>
                                <th>Rating</th>
                                <th>Playing With</th>
                                <th>Comment</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="shameBody"></tbody>
                    </table>
                </div>
                <div id="shameEmpty" class="empty-state" style="display: none;">No games in your backlog yet. Add some games above!</div>
                <div class="summary-box" id="shameSummary" style="display: none;">
                    <div class="summary-item">
                        <div class="summary-label">Total Main Hours</div>
                        <div class="summary-value" id="totalMain">0h</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Extra Hours</div>
                        <div class="summary-value" id="totalExtra">0h</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total 100% Hours</div>
                        <div class="summary-value" id="totalComplete">0h</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Cost</div>
                        <div class="summary-value" id="totalCost">€0.00</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Played</div>
                        <div class="summary-value" id="totalPlayed">0h</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Average €/h</div>
                        <div class="summary-value" id="avgValue">€0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="wishlist">
            <div class="section-header">
                <h2>
                    💫 Wishlist 
                    <span class="badge" id="wishlistCount">0</span>
                </h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="filter-toggle" onclick="toggleFilters('wishlist')">⚙️ Filters</div>
                <div class="filter-section" id="wishlistFilters">
                    <div class="filter-grid">
                        <div class="filter-item">
                            <label>Playtime (hours)</label>
                            <input type="number" id="wishlistFilterPlaytime" placeholder="Any" onchange="applyFilters('wishlist')">
                        </div>
                        <div class="filter-item">
                            <label>Difficulty</label>
                            <select id="wishlistFilterDifficulty" onchange="applyFilters('wishlist')">
                                <option value="">Any</option>
                                <option value="Easy">Easy</option>
                                <option value="Medium">Medium</option>
                                <option value="Hard">Hard</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Genre</label>
                            <select id="wishlistFilterGenre" onchange="applyFilters('wishlist')">
                                <option value="">Any</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="wishlistTable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Game</th>
                                <th>Main</th>
                                <th>Extra</th>
                                <th>100%</th>
                                <th>Difficulty</th>
                                <th>Platform</th>
                                <th>Genre</th>
                                <th>Est. Cost (€)</th>
                                <th>HDR</th>
                                <th>Rating</th>
                                <th>Comment</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="wishlistBody"></tbody>
                    </table>
                </div>
                <div id="wishlistEmpty" class="empty-state" style="display: block;">No games in your wishlist. Mark games as wishlist to track them here!</div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="completed">
            <div class="section-header">
                <h2>
                    ✅ Completed 
                    <span class="badge" id="completedCount">0</span>
                </h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="filter-toggle" onclick="toggleFilters('completed')">⚙️ Filters</div>
                <div class="filter-section" id="completedFilters">
                    <div class="filter-grid">
                        <div class="filter-item">
                            <label>Difficulty</label>
                            <select id="completedFilterDifficulty" onchange="applyFilters('completed')">
                                <option value="">Any</option>
                                <option value="Easy">Easy</option>
                                <option value="Medium">Medium</option>
                                <option value="Hard">Hard</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Genre</label>
                            <select id="completedFilterGenre" onchange="applyFilters('completed')">
                                <option value="">Any</option>
                            </select>
                        </div>
                        <div class="filter-item">
                            <label>Played Hours</label>
                            <input type="number" id="completedFilterPlayed" placeholder="Any" onchange="applyFilters('completed')">
                        </div>
                        <div class="filter-item">
                            <label>Rating</label>
                            <select id="completedFilterRating" onchange="applyFilters('completed')">
                                <option value="">Any</option>
                                <option value="5">5 Stars</option>
                                <option value="4">4+ Stars</option>
                                <option value="3">3+ Stars</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div style="overflow-x: auto;">
                    <table id="completedTable">
                        <thead>
                            <tr>
                                <th></th>
                                <th>✓</th>
                                <th>Game</th>
                                <th>Main</th>
                                <th>Extra</th>
                                <th>100%</th>
                                <th>Completed</th>
                                <th>♾️</th>
                                <th>🤝</th>
                                <th>Difficulty</th>
                                <th>Platform</th>
                                <th>Genre</th>
                                <th>Cost (€)</th>
                                <th>Played (h)</th>
                                <th>€/h</th>
                                <th>HDR</th>
                                <th>Rating</th>
                                <th>Playing With</th>
                                <th>Comment</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="completedBody"></tbody>
                    </table>
                </div>
                <div id="completedEmpty" class="empty-state" style="display: none;">No completed games yet. Check off games from your backlog!</div>
                <div class="summary-box" id="completedSummary" style="display: none;">
                    <div class="summary-item">
                        <div class="summary-label">Total Played</div>
                        <div class="summary-value" id="completedTotalPlayed">0h</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Cost</div>
                        <div class="summary-value" id="completedTotalCost">€0.00</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Average €/h</div>
                        <div class="summary-value" id="completedAvgValue">€0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="warnings">
            <div class="section-header">
                <h2>⚠️ Warning System</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="warning-item">
                    <label><input type="checkbox" id="enableWarnings" onchange="updateWarnings()"> Enable warnings</label>
                    <div class="warning-controls" id="warningControls" style="display: none;">
                        <div class="warning-input-group">
                            <label><input type="checkbox" id="warnGameCountEnabled" checked onchange="updateWarnings()"> Warn if more than</label>
                            <input type="number" id="warnGameCount" value="5" min="1" onchange="updateWarnings()">
                            <label>games playing</label>
                        </div>
                        <div class="warning-input-group">
                            <label><input type="checkbox" id="warnGenreCountEnabled" checked onchange="updateWarnings()"> Warn if more than</label>
                            <input type="number" id="warnGenreCount" value="3" min="1" onchange="updateWarnings()">
                            <label>games of same genre</label>
                        </div>
                        <div class="warning-filters">
                            <div class="filter-item">
                                <label>Exclude Status</label>
                                <div class="warning-checkbox-group">
                                    <label><input type="checkbox" id="warnExcludeNone" onchange="updateWarnings()"> None</label>
                                    <label><input type="checkbox" id="warnExcludeHold" onchange="updateWarnings()"> On Hold</label>
                                    <label><input type="checkbox" id="warnExcludeAbandoned" onchange="updateWarnings()"> Abandoned</label>
                                    <label><input type="checkbox" id="warnExcludePlaying" onchange="updateWarnings()"> Playing</label>
                                </div>
                            </div>
                            <div class="filter-item">
                                <label>Focus on Difficulty</label>
                                <div class="warning-checkbox-group">
                                    <label><input type="checkbox" id="warnDifficultyEasy" onchange="updateWarnings()"> Easy</label>
                                    <label><input type="checkbox" id="warnDifficultyMedium" onchange="updateWarnings()"> Medium</label>
                                    <label><input type="checkbox" id="warnDifficultyHard" onchange="updateWarnings()"> Hard</label>
                                </div>
                            </div>
                            <div class="filter-item">
                                <label>Properties</label>
                                <label><input type="checkbox" id="excludeNonSolo" onchange="updateWarnings()"> Exclude non-solo</label>
                                <label><input type="checkbox" id="excludeInfinite" onchange="updateWarnings()"> Exclude infinite</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="statistics">
            <div class="section-header">
                <h2>📊 Statistics & Overview</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="stats-filters">
                    <div class="stats-filter-group">
                        <label><input type="checkbox" id="statsAllTime" checked onchange="toggleAllTime()"> All Time</label>
                    </div>
                    <div class="stats-filter-group">
                        <label>Year:</label>
                        <input type="number" id="statsYear" placeholder="2024" min="2000" max="2100" disabled onchange="updateStatistics()">
                    </div>
                    <div class="stats-filter-group">
                        <label>Month:</label>
                        <select id="statsMonth" onchange="updateStatistics()">
                            <option value="">All Months</option>
                            <option value="1">January</option>
                            <option value="2">February</option>
                            <option value="3">March</option>
                            <option value="4">April</option>
                            <option value="5">May</option>
                            <option value="6">June</option>
                            <option value="7">July</option>
                            <option value="8">August</option>
                            <option value="9">September</option>
                            <option value="10">October</option>
                            <option value="11">November</option>
                            <option value="12">December</option>
                        </select>
                    </div>
                    <div class="stats-filter-group">
                        <label>Platform:</label>
                        <select id="statsPlatform" onchange="updateStatistics()">
                            <option value="">All Platforms</option>
                        </select>
                    </div>
                    <div class="stats-filter-group">
                        <label>Min Cost €:</label>
                        <input type="number" id="statsMinCost" placeholder="0" step="0.01" min="0" onchange="updateStatistics()">
                    </div>
                    <div class="stats-filter-group">
                        <label>Max Cost €:</label>
                        <input type="number" id="statsMaxCost" placeholder="Any" step="0.01" min="0" onchange="updateStatistics()">
                    </div>
                </div>
                <div class="stats-grid">
                    <div class="stats-card">
                        <h3>🏆 Completion Stats</h3>
                        <div class="stat-value" id="statCompletionRate">0%</div>
                        <div class="stat-label">Completion Rate</div>
                        <div style="margin-top: 10px;">
                            <div class="stat-value" id="statCompletedThisYear">0</div>
                            <div class="stat-label">Completed This Period</div>
                        </div>
                    </div>
                    <div class="stats-card">
                        <h3>📚 Backlog Overview</h3>
                        <div class="stat-value" id="statBacklogSize">0</div>
                        <div class="stat-label">Total Backlog</div>
                        <div style="margin-top: 10px;">
                            <div class="stat-value" id="statCurrentlyPlaying">0</div>
                            <div class="stat-label">Currently Playing</div>
                        </div>
                    </div>
                    <div class="stats-card">
                        <h3>⏱️ Time Analysis</h3>
                        <div class="stat-value" id="statTotalHours">0h</div>
                        <div class="stat-label">Total Played</div>
                        <div style="margin-top: 10px;">
                            <div class="stat-value" id="statAverageTime">0h</div>
                            <div class="stat-label">Average per Game</div>
                        </div>
                        <div style="margin-top: 10px;">
                            <div class="stat-value" id="statAvgCostPerHour">€0.00/h</div>
                            <div class="stat-label">Average Cost per Hour</div>
                        </div>
                    </div>
                    <div class="stats-card">
                        <h3>🎮 Genre Breakdown</h3>
                        <div id="genreBreakdown" style="font-size: 14px;"></div>
                    </div>
                    <div class="stats-card">
                        <h3>💰 Value Analysis</h3>
                        <div class="stat-value" id="statTotalInvested">€0.00</div>
                        <div class="stat-label">Total Invested</div>
                        <div style="margin-top: 10px;">
                            <div class="stat-value" id="statBestValue">€0.00/h</div>
                            <div class="stat-label">Best Value Game</div>
                        </div>
                    </div>
                    <div class="stats-card">
                        <h3>🎯 Platform Distribution</h3>
                        <div id="platformBreakdown" style="font-size: 14px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" draggable="true" data-section-id="tips">
            <div class="section-header">
                <h2>💡 Tips & Features</h2>
                <div class="header-controls">
                    <button class="collapse-btn" onclick="toggleSection(this)">▼</button>
                </div>
            </div>
            <div class="section-content">
                <div class="tips-grid">
                    <div class="tip-card">
                        <div class="tip-title">🎮 Status System</div>
                        <div class="tip-content">5 status options: None, Playing, On Hold, Abandoned, Wishlist. Games auto-move between sections when status changes. Visual warning banner shows when too many games are playing.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">♾️ Replayable Games</div>
                        <div class="tip-content">Mark endless games (multiplayer, roguelikes). They appear separately in timeline when filtered. Timeline properly handles infinite games without breaking.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🤝 Co-op & Friends</div>
                        <div class="tip-content">Track gaming partners! Add friends, click names to see shared games. Selecting friends doesn't auto-mark Solo anymore. Works properly when editing.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">📊 Smart Organization</div>
                        <div class="tip-content">Drag rows with visual blue corner indicators. Warning banner inside pile of shame with transparent orange background. All sections draggable.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">💾 Save System</div>
                        <div class="tip-content">Save HTML downloads complete tracker with all data. Orange glow = unsaved changes. Import CSV preserves all friend data correctly.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🎲 Game Picker</div>
                        <div class="tip-content">Random selector with filters: status, co-op, infinite, weekend-friendly. Weekend filter uses your time settings for smart suggestions.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🎨 Customization</div>
                        <div class="tip-content">18+ icon options. Edit title inline. 4 themes + dark mode. Sections collapsible. Warning system customizable.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">📅 Timeline Features</div>
                        <div class="tip-content">Completion timeline properly handles infinite games. Filters update timeline instantly. Click to jump highlights all status types. Hover shows game names.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">⚙️ Advanced Filters</div>
                        <div class="tip-content">Each section has filters that update in real-time. Combine multiple filters. Timeline filters properly refresh display.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">⚠️ Warning System</div>
                        <div class="tip-content">Orange banner with bold border inside pile of shame. Custom warnings for game count and genre concentration. Exclude statuses/properties.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">📈 Statistics</div>
                        <div class="tip-content">Dynamic stats with year input & month filters. Min/max cost range. Platform & genre breakdowns. Completion rates & value analysis.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">💬 Comments & Notes</div>
                        <div class="tip-content">Click comments for modal view/edit. Double-click for quick edit. Track progress, memories, or abandonment reasons.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🔍 Global Search</div>
                        <div class="tip-content">Searches all tables simultaneously. Filters by name, platform, genre. Instant results across all sections.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">📤 Import/Export</div>
                        <div class="tip-content">CSV export for spreadsheets. Import preserves ALL data including friends, ratings, HDR, playing with field.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🏷️ Value Tracking</div>
                        <div class="tip-content">Auto €/h calculations. Green = <€2/h (great), Orange = €2-5/h (good), Red = >€5/h (expensive). Summary totals for each section.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🌟 Ratings & HDR</div>
                        <div class="tip-content">5-star rating system. HDR tracking: None/Native/AutoHDR. Visual button indicators. All editable inline.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">⏰ Time Calculator</div>
                        <div class="tip-content">Enter weekday/weekend hours. Shows days to complete backlog. Timeline with hover effects and proper infinite game handling.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🔧 Auto Features</div>
                        <div class="tip-content">Co-op auto-activates with friends. Completion date auto-sets. Row colors by status. Hover tooltips. Enhanced drag & drop visuals.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">📱 Responsive</div>
                        <div class="tip-content">Works on all devices. Tables scroll horizontally on mobile. Touch-friendly buttons. Adaptive layouts.</div>
                    </div>
                    <div class="tip-card">
                        <div class="tip-title">🏁 Completion</div>
                        <div class="tip-content">Check box moves to completed. Track completion dates. Separate summaries with cost & time totals.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Comment Modal -->
    <div class="modal-overlay" id="modalOverlay" onclick="closeCommentModal()"></div>
    <div class="comment-modal" id="commentModal">
        <div class="comment-modal-header">
            <span class="comment-modal-title" id="modalTitle">Comment</span>
            <button class="comment-modal-close" onclick="closeCommentModal()">×</button>
        </div>
        <div class="comment-modal-content" id="modalContent"></div>
        <div class="comment-modal-actions" id="modalActions"></div>
    </div>

    <!-- Friend Modal -->
    <div class="friend-modal" id="friendModal">
        <div class="comment-modal-header">
            <span class="comment-modal-title" id="friendModalTitle">Friend's Games</span>
            <button class="comment-modal-close" onclick="closeFriendModal()">×</button>
        </div>
        <div class="friend-games-list" id="friendGamesList"></div>
    </div>

    <!-- Timeline Tooltip -->
    <div class="timeline-tooltip" id="timelineTooltip"></div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Embedded Data Storage -->
    <div id="gameDataContainer" style="display:none;"></div>

    <script>
        // Enhanced game tracker script with all improvements
        const platforms = ["PC", "Nintendo Switch", "Quest 3", "Phone", "PS5", "PS4", "Xbox Series X", "Xbox One"];
        const genres = ["Action", "Action RPG", "Adventure", "Fighting", "Horror", "Metroidvania", 
                       "MMORPG", "Platformer", "Puzzle", "Racing", "Rhythm", "Roguelike", 
                       "RPG", "Sandbox", "Shooter", "Simulation", "Soulslike", "Sports", "Strategy", 
                       "Survival", "Visual Novel"].sort();

        // Enhanced in-memory storage
        let games = {
            shame: [],
            wishlist: [],
            completed: [],
            friends: [],
            lastSaved: "",
            weekdayTime: 0,
            weekendTime: 0,
            theme: 'default',
            mode: 'light',
            appTitle: 'Game Backlog Tracker',
            appIcon: '🎮',
            sectionOrder: [],
            warnings: {
                enabled: false,
                gameCountEnabled: true,
                genreCountEnabled: true,
                gameCount: 5,
                genreCount: 3,
                excludeNonSolo: false,
                excludeInfinite: false,
                excludeStatuses: [],
                difficulties: []
            }
        };

        let draggedElement = null;
        let draggedSection = null;
        let searchTerm = '';
        let currentHDR = 'None';
        let currentRating = 0;
        let currentReplayable = false;
        let currentCoop = false;
        let currentPlayingWith = ['Solo'];
        let changesMade = false;
        let currentModalGameId = null;
        let currentModalMode = 'view';
        let tempComment = '';
        let activeFilters = {
            shame: {},
            wishlist: {},
            completed: {}
        };
        let dropTarget = null;

        // Status icons and titles
        const statusConfig = {
            'none': { icon: '○', title: 'None', class: 'status-none' },
            'playing': { icon: '▶', title: 'Playing', class: 'status-playing' },
            'hold': { icon: '⏸', title: 'On Hold', class: 'status-hold' },
            'abandoned': { icon: '❌', title: 'Abandoned', class: 'status-abandoned' },
            'wishlist': { icon: '💫', title: 'Wishlist', class: 'status-wishlist' },
            'completed': { icon: '✓', title: 'Completed', class: 'status-completed' }
        };

        // Sort function defined early
        function sortPileOfShame() {
            const statusOrder = { 'playing': 0, 'hold': 1, 'none': 2, 'abandoned': 3 };
            games.shame.sort((a, b) => {
                const statusA = statusOrder[a.status || 'none'] ?? 4;
                const statusB = statusOrder[b.status || 'none'] ?? 4;
                if (statusA !== statusB) return statusA - statusB;
                return 0;
            });
        }

        // Tooltip functions
        function showTooltip(event, text) {
            if (!text || text.trim() === '') return;
            const tooltip = document.getElementById('tooltip');
            if (!tooltip) return;
            
            tooltip.textContent = text;
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 30) + 'px';
            tooltip.classList.add('active');
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip) {
                tooltip.classList.remove('active');
            }
        }

        // App customization functions
        function toggleIconDropdown() {
            const dropdown = document.getElementById('iconDropdown');
            dropdown.classList.toggle('active');
        }

        function setIcon(icon) {
            document.getElementById('appIcon').firstChild.textContent = icon;
            games.appIcon = icon;
            document.getElementById('iconDropdown').classList.remove('active');
            saveData();
        }

        function saveTitle() {
            const titleElement = document.getElementById('appTitleText');
            titleElement.classList.remove('editing');
            const newTitle = titleElement.textContent.trim();
            if (newTitle) {
                games.appTitle = newTitle;
                document.getElementById('appTitle').textContent = newTitle;
                saveData();
            }
        }

        // Click outside to close icon dropdown
        document.addEventListener('click', function(e) {
            const iconElement = document.getElementById('appIcon');
            const dropdown = document.getElementById('iconDropdown');
            if (!iconElement.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        });



        // Section drag and drop
        function initSectionDragDrop() {
            const sections = document.querySelectorAll('.section, .search-section');
            const container = document.getElementById('sectionsContainer');

            sections.forEach(section => {
                section.addEventListener('dragstart', handleSectionDragStart);
                section.addEventListener('dragend', handleSectionDragEnd);
                section.addEventListener('dragover', handleSectionDragOver);
                section.addEventListener('drop', handleSectionDrop);
                section.addEventListener('dragleave', handleSectionDragLeave);
            });
        }

        function handleSectionDragStart(e) {
            if (e.target.classList.contains('section') || e.target.classList.contains('search-section')) {
                draggedSection = e.target;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            }
        }

        function handleSectionDragEnd(e) {
            if (draggedSection) {
                draggedSection.classList.remove('dragging');
                document.querySelectorAll('.section, .search-section').forEach(section => {
                    section.classList.remove('drag-over');
                });
                saveSectionOrder();
                draggedSection = null;
            }
        }

        function handleSectionDragOver(e) {
            if (draggedSection && e.currentTarget !== draggedSection) {
                e.preventDefault();
                e.currentTarget.classList.add('drag-over');
                
                const afterElement = getDragAfterElement(e.currentTarget.parentElement, e.clientY);
                if (afterElement == null) {
                    e.currentTarget.parentElement.appendChild(draggedSection);
                } else {
                    e.currentTarget.parentElement.insertBefore(draggedSection, afterElement);
                }
            }
        }

        function handleSectionDrop(e) {
            if (draggedSection) {
                e.preventDefault();
                e.currentTarget.classList.remove('drag-over');
            }
        }

        function handleSectionDragLeave(e) {
            if (e.currentTarget.classList.contains('drag-over')) {
                e.currentTarget.classList.remove('drag-over');
            }
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.section:not(.dragging), .search-section:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function saveSectionOrder() {
            const sections = document.querySelectorAll('.section, .search-section');
            games.sectionOrder = Array.from(sections).map(section => 
                section.getAttribute('data-section-id')
            ).filter(Boolean);
            saveData();
        }

        function restoreSectionOrder() {
            if (!games.sectionOrder || games.sectionOrder.length === 0) return;
            
            const container = document.getElementById('sectionsContainer');
            const appHeader = document.querySelector('.app-header');
            
            games.sectionOrder.forEach(sectionId => {
                const section = document.querySelector(`[data-section-id="${sectionId}"]`);
                if (section) {
                    container.appendChild(section);
                }
            });
        }

        // Friends system functions
        function addFriend() {
            const input = document.getElementById('friendName');
            const name = input.value.trim();
            
            if (name && !games.friends.includes(name)) {
                games.friends.push(name);
                input.value = '';
                renderFriends();
                saveData();
            }
        }

        function deleteFriend(name) {
            if (confirm(`Remove ${name} from friends list?`)) {
                games.friends = games.friends.filter(f => f !== name);
                // Update games that had this friend selected
                [...games.shame, ...games.wishlist, ...games.completed].forEach(game => {
                    if (game.playingWith && game.playingWith.includes(name)) {
                        game.playingWith = game.playingWith.filter(f => f !== name);
                        if (game.playingWith.length === 0) {
                            game.playingWith = ['Solo'];
                        }
                    }
                });
                renderFriends();
                renderTables();
                saveData();
            }
        }

        function showFriendGames(friendName) {
            const allGames = [...games.shame, ...games.wishlist, ...games.completed];
            const friendGames = allGames.filter(game => 
                game.playingWith && game.playingWith.includes(friendName)
            );
            
            const modal = document.getElementById('friendModal');
            const overlay = document.getElementById('modalOverlay');
            const title = document.getElementById('friendModalTitle');
            const list = document.getElementById('friendGamesList');
            
            title.textContent = `Games with ${friendName}`;
            
            if (friendGames.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No games with this friend yet</div>';
            } else {
                list.innerHTML = friendGames.map(game => {
                    const rowClass = getRowClass(game.status);
                    return `
                        <div class="friend-game-item ${rowClass}">
                            <div onmouseover="showTooltip(event, '${game.name.replace(/'/g, "\\'")}')" 
                                 onmouseout="hideTooltip()" 
                                 style="cursor: help;">${game.name}</div>
                            <div>${game.platform}</div>
                            <div>${statusConfig[game.status || 'none'].title}</div>
                            <div>${game.playedHours || 0}h played</div>
                        </div>
                    `;
                }).join('');
            }
            
            modal.classList.add('active');
            overlay.classList.add('active');
        }

        function closeFriendModal() {
            document.getElementById('friendModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function renderFriends() {
            const friendsList = document.getElementById('friendsList');
            if (games.friends.length === 0) {
                friendsList.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No friends added yet</div>';
            } else {
                friendsList.innerHTML = games.friends.map(friend => `
                    <div class="friend-item" title="Click to see games with ${friend}" onclick="showFriendGames('${friend}')">
                        <span>${friend}</span>
                        <span class="friend-delete" onclick="event.stopPropagation(); deleteFriend('${friend}')">&times;</span>
                    </div>
                `).join('');
            }
        }

        function openPlayingWithModal(gameIdOrType) {
            const modal = document.getElementById('commentModal');
            const overlay = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            const actions = document.getElementById('modalActions');
            const title = document.getElementById('modalTitle');
            
            // Get current selection
            let currentSelection;
            if (gameIdOrType === 'add') {
                currentSelection = [...currentPlayingWith];
            } else {
                const game = [...games.shame, ...games.wishlist, ...games.completed].find(g => g.id === gameIdOrType);
                currentSelection = game ? [...(game.playingWith || ['Solo'])] : ['Solo'];
            }
            
            // Store in tempPlayingWith for editing
            tempPlayingWith = [...currentSelection];
            
            title.textContent = 'Playing With';
            
            const friendOptions = ['Solo', ...games.friends];
            
            content.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    ${friendOptions.map((friend, index) => `
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 8px; border-radius: 5px;">
                            <input type="checkbox" ${tempPlayingWith.includes(friend) ? 'checked' : ''} 
                                   onchange="updatePlayingWithSelection('${gameIdOrType}', '${friend.replace(/'/g, "\\'")}', this.checked)"
                                   id="friend-check-${index}">
                            <span>${friend}</span>
                        </label>
                    `).join('')}
                </div>
            `;
            
            actions.innerHTML = `
                <button class="comment-modal-btn secondary" onclick="closePlayingWithModal()">Cancel</button>
                <button class="comment-modal-btn primary" onclick="savePlayingWithSelection('${gameIdOrType}')">Save</button>
            `;
            
            modal.classList.add('active');
            overlay.classList.add('active');
            currentModalGameId = gameIdOrType;
        }

        let tempPlayingWith = [];
        
        function updatePlayingWithSelection(gameIdOrType, friend, checked) {
            console.log(`Updating selection: ${friend} = ${checked}`);
            console.log('tempPlayingWith before:', tempPlayingWith);
            
            if (friend === 'Solo') {
                if (checked) {
                    tempPlayingWith = ['Solo'];
                    // Uncheck all other checkboxes
                    const friendOptions = ['Solo', ...games.friends];
                    friendOptions.forEach((f, index) => {
                        if (f !== 'Solo') {
                            const checkbox = document.getElementById(`friend-check-${index}`);
                            if (checkbox) checkbox.checked = false;
                        }
                    });
                }
            } else {
                if (checked) {
                    // Remove Solo and add friend
                    tempPlayingWith = tempPlayingWith.filter(f => f !== 'Solo');
                    if (!tempPlayingWith.includes(friend)) {
                        tempPlayingWith.push(friend);
                    }
                    // Uncheck Solo (index 0)
                    const soloCheckbox = document.getElementById('friend-check-0');
                    if (soloCheckbox) soloCheckbox.checked = false;
                } else {
                    // Remove friend
                    tempPlayingWith = tempPlayingWith.filter(f => f !== friend);
                    // If no friends selected, add Solo back
                    if (tempPlayingWith.length === 0) {
                        tempPlayingWith = ['Solo'];
                        const soloCheckbox = document.getElementById('friend-check-0');
                        if (soloCheckbox) soloCheckbox.checked = true;
                    }
                }
            }
            
            console.log('tempPlayingWith after:', tempPlayingWith);
        }

        function savePlayingWithSelection(gameIdOrType) {
            console.log('=== SAVE PLAYING WITH SELECTION ===');
            console.log('gameIdOrType:', gameIdOrType, 'type:', typeof gameIdOrType);
            console.log('tempPlayingWith:', tempPlayingWith);
            
            if (gameIdOrType === 'add') {
                console.log('Processing ADD case');
                currentPlayingWith = tempPlayingWith.length ? [...tempPlayingWith] : ['Solo'];
                document.getElementById('playingWith').value = currentPlayingWith.join(', ');
                console.log('Updated add form playingWith to:', currentPlayingWith);
                
                // Auto-set co-op if friends added
                if (!currentPlayingWith.includes('Solo') || currentPlayingWith.length > 1) {
                    currentCoop = true;
                    document.getElementById('coopBtn').classList.add('checked');
                }
            } else {
                console.log('Processing EXISTING GAME case');
                console.log('Searching for game ID:', gameIdOrType, 'type:', typeof gameIdOrType);
                
                // Log all game IDs and their types for debugging
                const allGames = games.shame.concat(games.wishlist, games.completed);
                console.log('All game IDs:', allGames.map(g => ({ id: g.id, type: typeof g.id, name: g.name })));
                
                // Try both number and string comparison
                const gameById = allGames.find(g => g.id === gameIdOrType);
                const gameByStringId = allGames.find(g => g.id === String(gameIdOrType));
                const gameByNumberId = allGames.find(g => g.id === Number(gameIdOrType));
                
                console.log('Found by direct match:', gameById ? gameById.name : 'null');
                console.log('Found by string conversion:', gameByStringId ? gameByStringId.name : 'null');
                console.log('Found by number conversion:', gameByNumberId ? gameByNumberId.name : 'null');
                
                const game = gameById || gameByStringId || gameByNumberId;
                console.log('Final game found:', game ? { id: game.id, name: game.name, playingWith: game.playingWith } : 'NULL');
                
                if (game) {
                    console.log('Game playingWith BEFORE update:', game.playingWith);
                    game.playingWith = tempPlayingWith.length ? [...tempPlayingWith] : ['Solo'];
                    console.log('Game playingWith AFTER update:', game.playingWith);
                    
                    // Auto-set co-op if friends added
                    if (!game.playingWith.includes('Solo') || game.playingWith.length > 1) {
                        console.log('Setting coop to true');
                        game.coop = true;
                    }
                    
                    console.log('About to render tables and save data...');
                    renderTables();
                    saveData();
                    console.log('Tables rendered and data saved');
                } else {
                    console.error('GAME NOT FOUND! ID:', gameIdOrType);
                }
            }
            
            console.log('Clearing tempPlayingWith and closing modal');
            tempPlayingWith = [];
            closePlayingWithModal();
            console.log('=== END SAVE PLAYING WITH SELECTION ===');
        }

        function closePlayingWithModal() {
            tempPlayingWith = [];
            document.getElementById('commentModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function closeCommentModal() {
            document.getElementById('commentModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');
        }

        // Warning system functions
        function updateWarnings() {
            const enabled = document.getElementById('enableWarnings').checked;
            document.getElementById('warningControls').style.display = enabled ? 'block' : 'none';
            
            games.warnings.enabled = enabled;
            games.warnings.gameCountEnabled = document.getElementById('warnGameCountEnabled').checked;
            games.warnings.genreCountEnabled = document.getElementById('warnGenreCountEnabled').checked;
            games.warnings.gameCount = parseInt(document.getElementById('warnGameCount').value);
            games.warnings.genreCount = parseInt(document.getElementById('warnGenreCount').value);
            games.warnings.excludeNonSolo = document.getElementById('excludeNonSolo').checked;
            games.warnings.excludeInfinite = document.getElementById('excludeInfinite').checked;
            
            // Collect excluded statuses
            games.warnings.excludeStatuses = [];
            if (document.getElementById('warnExcludeNone').checked) games.warnings.excludeStatuses.push('none');
            if (document.getElementById('warnExcludeHold').checked) games.warnings.excludeStatuses.push('hold');
            if (document.getElementById('warnExcludeAbandoned').checked) games.warnings.excludeStatuses.push('abandoned');
            if (document.getElementById('warnExcludePlaying').checked) games.warnings.excludeStatuses.push('playing');
            
            // Collect difficulty filters
            games.warnings.difficulties = [];
            if (document.getElementById('warnDifficultyEasy').checked) games.warnings.difficulties.push('Easy');
            if (document.getElementById('warnDifficultyMedium').checked) games.warnings.difficulties.push('Medium');
            if (document.getElementById('warnDifficultyHard').checked) games.warnings.difficulties.push('Hard');
            
            checkWarnings();
            saveData();
        }

        function checkWarnings() {
            const warningBanner = document.getElementById('warningBanner');
            const warningMessages = document.getElementById('warningMessages');
            
            if (!games.warnings.enabled) {
                warningBanner.classList.remove('active');
                return;
            }
            
            const messages = [];
            let playingGames = games.shame.filter(g => g.status === 'playing');
            
            // Apply exclusion filters
            games.warnings.excludeStatuses.forEach(status => {
                playingGames = playingGames.filter(g => g.status !== status);
            });
            
            if (games.warnings.excludeNonSolo) {
                playingGames = playingGames.filter(g => 
                    !g.playingWith || g.playingWith.length === 0 || 
                    (g.playingWith.length === 1 && g.playingWith[0] === 'Solo')
                );
            }
            
            if (games.warnings.excludeInfinite) {
                playingGames = playingGames.filter(g => !g.replayable);
            }
            
            if (games.warnings.difficulties.length > 0) {
                playingGames = playingGames.filter(g => games.warnings.difficulties.includes(g.difficulty));
            }
            
            // Check game count
            if (games.warnings.gameCountEnabled && playingGames.length > games.warnings.gameCount) {
                messages.push(`You have ${playingGames.length} games with Playing status (max: ${games.warnings.gameCount})`);
            }
            
            // Check genre counts
            if (games.warnings.genreCountEnabled) {
                const genreCounts = {};
                playingGames.forEach(game => {
                    if (game.genre && game.genre !== 'Unknown') {
                        genreCounts[game.genre] = (genreCounts[game.genre] || 0) + 1;
                    }
                });
                
                Object.entries(genreCounts).forEach(([genre, count]) => {
                    if (count > games.warnings.genreCount) {
                        messages.push(`${count} ${genre} games playing (max: ${games.warnings.genreCount})`);
                    }
                });
            }
            
            if (messages.length > 0) {
                warningBanner.classList.add('active');
                warningMessages.innerHTML = messages.map(msg => 
                    `<div class="warning-message">${msg}</div>`
                ).join('');
            } else {
                warningBanner.classList.remove('active');
            }
        }

        // Statistics functions
        function toggleAllTime() {
            const allTimeChecked = document.getElementById('statsAllTime').checked;
            const yearInput = document.getElementById('statsYear');
            
            if (allTimeChecked) {
                yearInput.disabled = true;
                yearInput.value = '';
            } else {
                yearInput.disabled = false;
                yearInput.value = new Date().getFullYear();
            }
            
            updateStatistics();
        }
        
        function updateStatistics() {
            const allTime = document.getElementById('statsAllTime').checked;
            const yearFilter = !allTime ? document.getElementById('statsYear').value : '';
            const monthFilter = document.getElementById('statsMonth').value;
            const platformFilter = document.getElementById('statsPlatform').value;
            const minCost = parseFloat(document.getElementById('statsMinCost').value);
            const maxCost = parseFloat(document.getElementById('statsMaxCost').value);
            
            let allGames = [...games.shame, ...games.wishlist, ...games.completed];
            
            // Apply filters
            if (yearFilter) {
                allGames = allGames.filter(game => {
                    if (game.completedDate) {
                        const year = new Date(game.completedDate).getFullYear();
                        return year.toString() === yearFilter;
                    }
                    return false;
                });
            }
            
            if (monthFilter && yearFilter) {
                allGames = allGames.filter(game => {
                    if (game.completedDate) {
                        const date = new Date(game.completedDate);
                        const month = date.getMonth() + 1;
                        return month.toString() === monthFilter;
                    }
                    return false;
                });
            }
            
            if (platformFilter) {
                allGames = allGames.filter(game => game.platform === platformFilter);
            }
            
            // Apply cost filters
            if (!isNaN(minCost) && minCost >= 0) {
                allGames = allGames.filter(game => {
                    const cost = parseFloat(game.cost) || 0;
                    return cost >= minCost;
                });
            }
            
            if (!isNaN(maxCost) && maxCost > 0) {
                allGames = allGames.filter(game => {
                    const cost = parseFloat(game.cost) || 0;
                    return cost <= maxCost;
                });
            }
            
            const completedCount = allGames.filter(g => g.completed).length;
            const totalCount = allGames.filter(g => g.status !== 'wishlist').length;
            
            // Completion stats
            const completionRate = totalCount > 0 ? ((completedCount / totalCount) * 100).toFixed(1) : 0;
            document.getElementById('statCompletionRate').textContent = `${completionRate}%`;
            document.getElementById('statCompletedThisYear').textContent = completedCount;
            
            // Backlog overview
            document.getElementById('statBacklogSize').textContent = allGames.filter(g => !g.completed && g.status !== 'wishlist').length;
            document.getElementById('statCurrentlyPlaying').textContent = allGames.filter(g => g.status === 'playing').length;
            
            // Time analysis
            const totalPlayed = allGames.reduce((sum, game) => sum + (parseFloat(game.playedHours) || 0), 0);
            document.getElementById('statTotalHours').textContent = `${totalPlayed.toFixed(1)}h`;
            
            const gamesWithTime = allGames.filter(g => g.playedHours > 0);
            const averageTime = gamesWithTime.length > 0 ? (totalPlayed / gamesWithTime.length).toFixed(1) : 0;
            document.getElementById('statAverageTime').textContent = `${averageTime}h`;
            
            // Calculate average cost per hour
            const totalCost = allGames.reduce((sum, game) => sum + (parseFloat(game.cost) || 0), 0);
            const avgCostPerHour = totalPlayed > 0 ? (totalCost / totalPlayed).toFixed(2) : '0.00';
            document.getElementById('statAvgCostPerHour').textContent = `€${avgCostPerHour}/h`;
            
            // Genre breakdown
            const genreCounts = {};
            allGames.forEach(game => {
                if (game.genre && game.genre !== 'Unknown') {
                    genreCounts[game.genre] = (genreCounts[game.genre] || 0) + 1;
                }
            });
            
            const sortedGenres = Object.entries(genreCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            document.getElementById('genreBreakdown').innerHTML = sortedGenres
                .map(([genre, count]) => `<div>${genre}: ${count}</div>`)
                .join('') || '<div>No genre data</div>';
            
            // Value analysis
            document.getElementById('statTotalInvested').textContent = `€${totalCost.toFixed(2)}`;
            
            const gamesWithValue = allGames.filter(g => g.playedHours > 0 && g.cost > 0);
            const bestValueGame = gamesWithValue.reduce((best, game) => {
                if (!best) return game;
                const value = game.cost / game.playedHours;
                return value < (best.cost / best.playedHours) ? game : best;
            }, gamesWithValue[0]);
            
            const bestValue = bestValueGame ? (bestValueGame.cost / bestValueGame.playedHours).toFixed(2) : '0';
            document.getElementById('statBestValue').textContent = `€${bestValue}/h`;
            
            // Platform distribution
            const platformCounts = {};
            allGames.forEach(game => {
                if (game.platform && game.platform !== 'Unknown' && game.platform !== '') {
                    platformCounts[game.platform] = (platformCounts[game.platform] || 0) + 1;
                }
            });
            
            const sortedPlatforms = Object.entries(platformCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            document.getElementById('platformBreakdown').innerHTML = sortedPlatforms
                .map(([platform, count]) => `<div>${platform}: ${count}</div>`)
                .join('') || '<div>No platform data</div>';
        }

        // Timeline functions
        function updateTimeline() {
            const timeline = document.getElementById('gameTimeline');
            const weekdayTime = games.weekdayTime || 0;
            const weekendTime = games.weekendTime || 0;
            const weeklyHours = (weekdayTime * 5) + (weekendTime * 2);
            
            if (weeklyHours <= 0) {
                timeline.innerHTML = '<div class="timeline-line"></div><div class="timeline-empty-message">Enter gaming hours to see timeline</div>';
                return;
            }
            
            const limit = parseInt(document.getElementById('timelineLimit').value) || 10;
            
            // Get filter states
            const includePlaying = document.getElementById('timelinePlaying').checked;
            const includeHold = document.getElementById('timelineHold').checked;
            const includeNone = document.getElementById('timelineNone').checked;
            const filterInfinite = document.getElementById('timelineInfinite').checked;
            const filterCoop = document.getElementById('timelineCoop').checked;
            
            // Filter games - maintain original order
            let eligibleGames = games.shame.filter(g => {
                if (g.status === 'wishlist') return false;
                
                // Status filter
                if (!includePlaying && g.status === 'playing') return false;
                if (!includeHold && g.status === 'hold') return false;
                if (!includeNone && (g.status === 'none' || !g.status)) return false;
                
                // Property filters - if checked, show ONLY those games
                if (filterInfinite && !g.replayable) return false;
                if (filterCoop && !g.coop) return false;
                
                return true;
            });
            
            // For timeline, filter out infinite games unless they have time estimates
            let timelineGames = eligibleGames.filter(g => {
                const hasTimeEstimate = parseHours(g.lengthMain) > 0 || parseHours(g.lengthExtra) > 0 || parseHours(g.lengthComplete) > 0;
                // Include regular games with time estimates OR infinite games with time estimates if filter is on
                if (!g.replayable) {
                    return hasTimeEstimate;
                } else {
                    // Only show infinite games if they have time estimates
                    return filterInfinite && hasTimeEstimate;
                }
            });
            
            // Take only the first N games
            const gamesToShow = timelineGames.slice(0, limit);
            
            if (gamesToShow.length === 0) {
                timeline.innerHTML = '<div class="timeline-line"></div><div class="timeline-empty-message">No games match selected filters</div>';
                return;
            }
            
            // Calculate timeline
            let timelineHTML = '<div class="timeline-line"></div>';
            const now = new Date();
            let cumulativeHours = 0;
            
            // Calculate positions for games
            const positions = [];
            const minSpacing = 8; // Minimum percentage between items
            let finiteGameHours = 0;
            
            gamesToShow.forEach((game, index) => {
                const mainHours = parseHours(game.lengthMain);
                const extraHours = parseHours(game.lengthExtra);
                const avgHours = (mainHours + extraHours) / 2 || mainHours || extraHours || 0;
                const remainingHours = game.status === 'playing' ? 
                    Math.max(0, avgHours - (parseFloat(game.playedHours) || 0)) : avgHours;
                
                let position;
                let finishDate;
                
                if (!game.replayable) {
                    // Regular game - add to cumulative hours
                    finiteGameHours += remainingHours;
                    const weeksToFinish = finiteGameHours / weeklyHours;
                    finishDate = new Date(now.getTime() + (weeksToFinish * 7 * 24 * 60 * 60 * 1000));
                    
                    // Position based on time to complete
                    const totalTimelineHours = gamesToShow.filter(g => !g.replayable)
                        .reduce((total, g) => {
                            const mH = parseHours(g.lengthMain);
                            const eH = parseHours(g.lengthExtra);
                            const aH = (mH + eH) / 2 || mH || eH || 0;
                            return total + (g.status === 'playing' ? 
                                Math.max(0, aH - (parseFloat(g.playedHours) || 0)) : aH);
                        }, 0);
                    
                    if (totalTimelineHours > 0) {
                        position = Math.min(85, (finiteGameHours / totalTimelineHours) * 75 + 5);
                    } else {
                        position = 5 + (index * 10); // Fallback
                    }
                } else {
                    // Infinite game - position evenly in remaining space
                    const infiniteGames = gamesToShow.filter(g => g.replayable);
                    const infiniteIndex = infiniteGames.indexOf(game);
                    position = 90 - (infiniteIndex * 15); // Place at end, spaced backwards
                    finishDate = null; // No finish date for infinite games
                }
                
                // Ensure minimum spacing and avoid overlaps
                let finalPosition = position;
                let attempts = 0;
                while (positions.some(pos => Math.abs(finalPosition - pos) < minSpacing) && attempts < 10) {
                    finalPosition += minSpacing;
                    attempts++;
                }
                
                // Keep within bounds
                finalPosition = Math.max(5, Math.min(95, finalPosition));
                positions.push(finalPosition);
                
                const statusClass = `status-${game.status || 'none'}`;
                const gameLabel = game.replayable ? '♾️ ' + game.name : game.name;
                
                timelineHTML += `
                    <div class="timeline-item ${statusClass}" 
                         style="left: ${finalPosition}%;"
                         onclick="jumpToGame(${game.id})"
                         onmouseover="showTimelineTooltip(event, '${game.name.replace(/'/g, "\\'")}')"
                         onmouseout="hideTimelineTooltip()">
                        ${gameLabel.substring(0, 12)}${gameLabel.length > 12 ? '..' : ''}
                    </div>
                    <div class="timeline-date" style="left: ${finalPosition}%;">
                        ${game.replayable ? '∞' : (finishDate ? finishDate.toLocaleDateString('en-GB', { month: 'short', day: '2-digit' }) : '—')}
                    </div>
                `;
            });
            
            timeline.innerHTML = timelineHTML;
            
            // Update time calculation text based on filters
            updateTimeCalculation();
        }

        function showTimelineTooltip(event, gameName) {
            const tooltip = document.getElementById('timelineTooltip');
            tooltip.textContent = gameName;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 30 + 'px';
            tooltip.classList.add('active');
        }

        function hideTimelineTooltip() {
            document.getElementById('timelineTooltip').classList.remove('active');
        }

        function jumpToGame(gameId) {
            console.log('Scrolling to and blinking game ID:', gameId);
            
            // Clear any existing highlights first
            document.querySelectorAll('.highlight-row').forEach(row => {
                row.classList.remove('highlight-row');
            });
            
            const allRows = document.querySelectorAll('tr');
            let foundRow = false;
            
            allRows.forEach(row => {
                if (row.innerHTML && row.innerHTML.includes(`updateGameField(${gameId},`)) {
                    foundRow = true;
                    console.log('Found matching row for game ID:', gameId);
                    
                    // Scroll page to the row
                    row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Apply blink after brief delay for scroll
                    setTimeout(() => {
                        console.log('Applying blink animation to row');
                        
                        // Force any existing animation to stop
                        row.classList.remove('highlight-row');
                        row.offsetHeight; // Force reflow
                        
                        // Add highlight class
                        row.classList.add('highlight-row');
                        
                        // Remove highlight after animation completes
                        setTimeout(() => {
                            console.log('Removing blink animation');
                            row.classList.remove('highlight-row');
                        }, 4000);
                    }, 300); // Brief delay for scroll
                }
            });
            
            if (!foundRow) {
                console.log('Could not find game row for ID:', gameId);
            }
        }

        // Game Picker function
        function pickGame() {
            let eligibleGames = games.shame.filter(g => g.status !== 'wishlist');
            
            // Apply filters
            const filters = {
                playing: document.getElementById('pickerPlaying').checked,
                hold: document.getElementById('pickerHold').checked,
                none: document.getElementById('pickerNone').checked,
                abandoned: document.getElementById('pickerAbandoned').checked,
                coop: document.getElementById('pickerCoop').checked,
                infinite: document.getElementById('pickerInfinite').checked,
                weekend: document.getElementById('pickerWeekend').checked
            };
            
            eligibleGames = eligibleGames.filter(game => {
                // Status filters
                if (!filters.playing && game.status === 'playing') return false;
                if (!filters.hold && game.status === 'hold') return false;
                if (!filters.none && (game.status === 'none' || !game.status)) return false;
                if (!filters.abandoned && game.status === 'abandoned') return false;
                
                // Property filters (exclusive)
                if (filters.coop && !game.coop) return false;
                if (filters.infinite && !game.replayable) return false;
                
                // Weekend filter
                if (filters.weekend) {
                    const weekendHours = (games.weekendTime || 0) * 2;
                    if (weekendHours === 0) return false;
                    
                    const mainHours = parseHours(game.lengthMain);
                    const extraHours = parseHours(game.lengthExtra);
                    const avgHours = (mainHours + extraHours) / 2;
                    const remainingHours = avgHours - (parseFloat(game.playedHours) || 0);
                    
                    if (remainingHours <= 0 || remainingHours > weekendHours * 1.5) return false;
                }
                
                return true;
            });
            
            if (eligibleGames.length === 0) {
                document.getElementById('pickerResult').innerHTML = '<div class="suggested-info">No games match selected filters</div>';
                return;
            }
            
            const randomGame = eligibleGames[Math.floor(Math.random() * eligibleGames.length)];
            document.getElementById('pickerResult').innerHTML = `
                <div class="suggested-game">${randomGame.name}</div>
                <div class="suggested-info">${randomGame.platform} • ${randomGame.genre} • ${randomGame.difficulty}</div>
            `;
        }

        // Filter system functions
        function toggleFilters(section) {
            const filterSection = document.getElementById(`${section}Filters`);
            filterSection.classList.toggle('active');
        }

        function applyFilters(section) {
            activeFilters[section] = {};
            
            // Gather filter values based on section
            if (section === 'shame') {
                const playtime = document.getElementById('shameFilterPlaytime').value;
                if (playtime) activeFilters[section].playtime = parseFloat(playtime);
                
                const completion = document.getElementById('shameFilterCompletion').value;
                if (completion) activeFilters[section].completion = completion;
                
                const status = document.getElementById('shameFilterStatus').value;
                if (status) activeFilters[section].status = status;
                
                const difficulty = document.getElementById('shameFilterDifficulty').value;
                if (difficulty) activeFilters[section].difficulty = difficulty;
                
                const genre = document.getElementById('shameFilterGenre').value;
                if (genre) activeFilters[section].genre = genre;
                
                if (document.getElementById('shameFilterInfinite').checked) {
                    activeFilters[section].infinite = true;
                }
                
                if (document.getElementById('shameFilterCoop').checked) {
                    activeFilters[section].coop = true;
                }
            }
            
            renderTables();
            updateTimeline();
        }

        function filterGames(gamesList, section) {
            let filtered = gamesList;
            
            // Apply search term
            if (searchTerm) {
                filtered = filtered.filter(game => {
                    const searchableText = `${game.name} ${game.platform} ${game.genre}`.toLowerCase();
                    return searchableText.includes(searchTerm);
                });
            }
            
            // Apply section-specific filters
            const filters = activeFilters[section];
            if (filters) {
                if (filters.playtime !== undefined) {
                    filtered = filtered.filter(game => {
                        const hours = parseHours(game.lengthMain);
                        return hours <= filters.playtime;
                    });
                }
                
                if (filters.status) {
                    filtered = filtered.filter(game => game.status === filters.status);
                }
                
                if (filters.difficulty) {
                    filtered = filtered.filter(game => game.difficulty === filters.difficulty);
                }
                
                if (filters.genre) {
                    filtered = filtered.filter(game => game.genre === filters.genre);
                }
                
                if (filters.infinite) {
                    filtered = filtered.filter(game => game.replayable);
                }
                
                if (filters.coop) {
                    filtered = filtered.filter(game => game.coop);
                }
            }
            
            return filtered;
        }

        // Core functions
        function toggleCoop() {
            currentCoop = !currentCoop;
            const btn = document.getElementById('coopBtn');
            if (currentCoop) {
                btn.classList.add('checked');
            } else {
                btn.classList.remove('checked');
            }
        }

        function toggleReplayable() {
            currentReplayable = !currentReplayable;
            const btn = document.getElementById('replayableBtn');
            if (currentReplayable) {
                btn.classList.add('checked');
            } else {
                btn.classList.remove('checked');
            }
        }

        function updateTimeCalculation() {
            const weekdayTime = parseFloat(document.getElementById('weekdayTime').value) || 0;
            const weekendTime = parseFloat(document.getElementById('weekendTime').value) || 0;
            games.weekdayTime = weekdayTime;
            games.weekendTime = weekendTime;
            
            const weeklyHours = (weekdayTime * 5) + (weekendTime * 2);
            
            if (weeklyHours > 0) {
                // Get timeline filter states
                const includePlaying = document.getElementById('timelinePlaying')?.checked ?? true;
                const includeHold = document.getElementById('timelineHold')?.checked ?? true;
                const includeNone = document.getElementById('timelineNone')?.checked ?? true;
                const filterInfinite = document.getElementById('timelineInfinite')?.checked ?? false;
                const filterCoop = document.getElementById('timelineCoop')?.checked ?? false;
                
                // Filter games based on timeline settings
                let eligibleGames = games.shame.filter(g => {
                    if (g.status === 'wishlist') return false;
                    if (!g.replayable) { // Only count non-replayable games for completion time
                        if (!includePlaying && g.status === 'playing') return false;
                        if (!includeHold && g.status === 'hold') return false;
                        if (!includeNone && (g.status === 'none' || !g.status)) return false;
                        if (filterInfinite && !g.replayable) return false;
                        if (filterCoop && !g.coop) return false;
                        return true;
                    }
                    return false;
                });
                
                let totalHours = 0;
                let gameCount = 0;
                
                eligibleGames.forEach(game => {
                    const mainHours = parseHours(game.lengthMain);
                    const extraHours = parseHours(game.lengthExtra);
                    if (mainHours > 0 || extraHours > 0) {
                        const remainingHours = game.status === 'playing' ? 
                            Math.max(0, ((mainHours + extraHours) / 2) - (parseFloat(game.playedHours) || 0)) : 
                            (mainHours + extraHours) / 2;
                        totalHours += remainingHours;
                        gameCount++;
                    }
                });
                
                if (totalHours > 0) {
                    const weeksNeeded = totalHours / weeklyHours;
                    const daysNeeded = Math.ceil(weeksNeeded * 7);
                    const months = Math.floor(daysNeeded / 30);
                    const remainingDays = daysNeeded % 30;
                    const avgPerGame = totalHours / gameCount;
                    
                    let timeText = `${daysNeeded} days to complete filtered games`;
                    if (months > 0) {
                        timeText = `${months} month${months > 1 ? 's' : ''} and ${remainingDays} day${remainingDays !== 1 ? 's' : ''} to complete filtered games`;
                    }
                    
                    document.getElementById('timeCalculation').innerHTML = `
                        <div>${timeText}</div>
                        <div class="time-details">
                            Based on ${totalHours.toFixed(1)}h total (avg of main+extra) across ${gameCount} games<br>
                            Exact: ${daysNeeded} days • Average ${avgPerGame.toFixed(1)}h per game
                        </div>
                    `;
                } else {
                    document.getElementById('timeCalculation').innerHTML = '<div>No games with time estimates in filtered backlog</div>';
                }
            } else {
                document.getElementById('timeCalculation').innerHTML = '<div>Enter your free time to see completion estimate</div>';
            }
            
            saveData();
        }

        function setTheme(theme) {
            document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.theme-${theme}`).classList.add('active');
            document.documentElement.setAttribute('data-theme', theme);
            games.theme = theme;
            saveData();
        }

        function toggleMode() {
            const currentMode = document.documentElement.getAttribute('data-mode') || 'light';
            const newMode = currentMode === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-mode', newMode);
            document.querySelector('.mode-toggle').textContent = newMode === 'dark' ? '☀️' : '🌙';
            games.mode = newMode;
            saveData();
        }

        function toggleSection(button) {
            const section = button.closest('.section');
            const content = section.querySelector('.section-content');
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                content.classList.remove('collapsed');
                section.classList.remove('collapsed');
                button.classList.remove('collapsed');
                button.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                section.classList.add('collapsed');
                button.classList.add('collapsed');
                button.textContent = '▶';
            }
        }

        function trackChange() {
            changesMade = true;
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn && !saveBtn.classList.contains('unsaved')) {
                saveBtn.classList.add('unsaved');
                saveBtn.innerHTML = '💾 Save HTML *';
            }
        }

        window.addEventListener('beforeunload', function(e) {
            if (changesMade) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Remember to click "Save HTML" to keep your data!';
            }
        });

        function changeGameStatus(id, newStatus) {
            const game = [...games.shame, ...games.wishlist].find(g => g.id === id);
            if (game) {
                const oldStatus = game.status || 'none';
                
                if (oldStatus === 'wishlist' && newStatus !== 'wishlist') {
                    const index = games.wishlist.findIndex(g => g.id === id);
                    if (index !== -1) {
                        games.wishlist.splice(index, 1);
                        game.status = newStatus;
                        games.shame.push(game);
                    }
                } else if (oldStatus !== 'wishlist' && newStatus === 'wishlist') {
                    const index = games.shame.findIndex(g => g.id === id);
                    if (index !== -1) {
                        games.shame.splice(index, 1);
                        game.status = newStatus;
                        games.wishlist.push(game);
                    }
                } else {
                    game.status = newStatus;
                }
                
                saveData();
                renderTables();
                updateTimeline();
                checkWarnings();
            }
        }

        function parseHours(str) {
            if (!str || str === 'N/A' || str === '') return 0;
            return parseFloat(str.toString().replace(/[h\s]/g, '')) || 0;
        }

        function calculateSummaries() {
            const shameGames = games.shame || [];
            const completedGames = games.completed || [];
            
            let totalMain = 0, totalExtra = 0, totalComplete = 0, totalCost = 0, totalPlayed = 0;
            
            shameGames.forEach(game => {
                if (game.status !== 'wishlist') {
                    if (!game.replayable) {
                        totalMain += parseHours(game.lengthMain);
                        totalExtra += parseHours(game.lengthExtra);
                        totalComplete += parseHours(game.lengthComplete);
                    }
                    totalCost += parseFloat(game.cost) || 0;
                    totalPlayed += parseFloat(game.playedHours) || 0;
                }
            });
            
            const avgValue = totalPlayed > 0 ? (totalCost / totalPlayed).toFixed(2) : '0';
            
            document.getElementById('totalMain').textContent = totalMain.toFixed(1) + 'h';
            document.getElementById('totalExtra').textContent = totalExtra.toFixed(1) + 'h';
            document.getElementById('totalComplete').textContent = totalComplete.toFixed(1) + 'h';
            document.getElementById('totalCost').textContent = '€' + totalCost.toFixed(2);
            document.getElementById('totalPlayed').textContent = totalPlayed.toFixed(1) + 'h';
            document.getElementById('avgValue').textContent = '€' + avgValue;
            
            let completedCost = 0, completedPlayed = 0;
            
            completedGames.forEach(game => {
                completedCost += parseFloat(game.cost) || 0;
                completedPlayed += parseFloat(game.playedHours) || 0;
            });
            
            const completedAvg = completedPlayed > 0 ? (completedCost / completedPlayed).toFixed(2) : '0';
            
            document.getElementById('completedTotalPlayed').textContent = completedPlayed.toFixed(1) + 'h';
            document.getElementById('completedTotalCost').textContent = '€' + completedCost.toFixed(2);
            document.getElementById('completedAvgValue').textContent = '€' + completedAvg;
            
            document.getElementById('shameSummary').style.display = shameGames.filter(g => g.status !== 'wishlist').length > 0 ? 'grid' : 'none';
            document.getElementById('completedSummary').style.display = completedGames.length > 0 ? 'grid' : 'none';
        }

        function loadData() {
            try {
                const dataContainer = document.getElementById('gameDataContainer');
                if (dataContainer && dataContainer.textContent && dataContainer.textContent.trim() !== '') {
                    const dataText = dataContainer.textContent.trim();
                    const parsed = JSON.parse(dataText);
                    if (parsed) {
                        games = parsed;
                        
                        // Ensure all required fields exist
                        games.warnings = games.warnings || {
                            enabled: false,
                            gameCountEnabled: true,
                            genreCountEnabled: true,
                            gameCount: 5,
                            genreCount: 3,
                            excludeNonSolo: false,
                            excludeInfinite: false,
                            excludeStatuses: [],
                            difficulties: []
                        };
                        
                        if (games.theme) {
                            setTheme(games.theme);
                        }
                        if (games.mode === 'dark') {
                            document.documentElement.setAttribute('data-mode', 'dark');
                            document.querySelector('.mode-toggle').textContent = '☀️';
                        }
                        
                        if (games.appTitle) {
                            document.getElementById('appTitleText').textContent = games.appTitle;
                            document.getElementById('appTitle').textContent = games.appTitle;
                        }
                        
                        if (games.appIcon) {
                            document.getElementById('appIcon').firstChild.textContent = games.appIcon;
                        }
                        
                        if (games.lastSaved) {
                            document.getElementById('lastSaved').textContent = 'Last saved: ' + games.lastSaved;
                        }
                        
                        if (games.weekdayTime > 0) {
                            document.getElementById('weekdayTime').value = games.weekdayTime;
                        }
                        if (games.weekendTime > 0) {
                            document.getElementById('weekendTime').value = games.weekendTime;
                        }
                        
                        // Load warning settings
                        if (games.warnings) {
                            document.getElementById('enableWarnings').checked = games.warnings.enabled;
                            document.getElementById('warnGameCountEnabled').checked = games.warnings.gameCountEnabled ?? true;
                            document.getElementById('warnGenreCountEnabled').checked = games.warnings.genreCountEnabled ?? true;
                            document.getElementById('warnGameCount').value = games.warnings.gameCount || 5;
                            document.getElementById('warnGenreCount').value = games.warnings.genreCount || 3;
                            document.getElementById('excludeNonSolo').checked = games.warnings.excludeNonSolo;
                            document.getElementById('excludeInfinite').checked = games.warnings.excludeInfinite;
                            
                            // Load status exclusions
                            if (games.warnings.excludeStatuses) {
                                document.getElementById('warnExcludeNone').checked = games.warnings.excludeStatuses.includes('none');
                                document.getElementById('warnExcludeHold').checked = games.warnings.excludeStatuses.includes('hold');
                                document.getElementById('warnExcludeAbandoned').checked = games.warnings.excludeStatuses.includes('abandoned');
                                document.getElementById('warnExcludePlaying').checked = games.warnings.excludeStatuses.includes('playing');
                            }
                            
                            // Load difficulty filters
                            if (games.warnings.difficulties) {
                                document.getElementById('warnDifficultyEasy').checked = games.warnings.difficulties.includes('Easy');
                                document.getElementById('warnDifficultyMedium').checked = games.warnings.difficulties.includes('Medium');
                                document.getElementById('warnDifficultyHard').checked = games.warnings.difficulties.includes('Hard');
                            }
                            
                            updateWarnings();
                        }
                    }
                }
            } catch (e) {
                console.log('Starting with empty data');
            }
            
            games.shame = games.shame || [];
            games.wishlist = games.wishlist || [];
            games.completed = games.completed || [];
            games.friends = games.friends || [];
            
            // Populate platform filter
            const platformSelect = document.getElementById('statsPlatform');
            platformSelect.innerHTML = '<option value="">All Platforms</option>' + 
                platforms.map(p => `<option value="${p}">${p}</option>`).join('');
            
            renderFriends();
            renderTables();
            updateTimeCalculation();
            updateStatistics();
            restoreSectionOrder();
            checkWarnings();
        }

        function saveData() {
            trackChange();
        }

        function saveHTML() {
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }) + 
                            ' - ' + 
                            now.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
            games.lastSaved = timestamp;
            
            let htmlContent = document.documentElement.outerHTML;
            
            const dataString = JSON.stringify(games);
            const dataContainerStart = '<div id="gameDataContainer" style="display:none;">';
            const dataContainerEnd = '</div>';
            const startIndex = htmlContent.indexOf(dataContainerStart);
            
            if (startIndex !== -1) {
                let endIndex = startIndex + dataContainerStart.length;
                let depth = 1;
                while (depth > 0 && endIndex < htmlContent.length) {
                    if (htmlContent.substring(endIndex, endIndex + 5) === '<div ') {
                        depth++;
                    } else if (htmlContent.substring(endIndex, endIndex + 6) === '</div>') {
                        depth--;
                        if (depth === 0) {
                            endIndex += 6;
                            break;
                        }
                    }
                    endIndex++;
                }
                
                const beforeData = htmlContent.substring(0, startIndex + dataContainerStart.length);
                const afterData = htmlContent.substring(endIndex - 6);
                htmlContent = beforeData + dataString + afterData;
            }
            
            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'game-backlog-tracker.html';
            a.click();
            window.URL.revokeObjectURL(url);
            
            document.getElementById('lastSaved').textContent = 'Last saved: ' + timestamp;
            document.getElementById('gameDataContainer').textContent = dataString;
            
            changesMade = false;
            const saveBtn = document.getElementById('saveBtn');
            if (saveBtn) {
                saveBtn.classList.remove('unsaved');
                saveBtn.innerHTML = '💾 Save HTML';
            }
        }

        function updateDifficultyStyle(select) {
            select.className = 'difficulty-select';
            if (select.value === 'Easy') {
                select.classList.add('easy');
            } else if (select.value === 'Medium') {
                select.classList.add('medium');
            } else if (select.value === 'Hard') {
                select.classList.add('hard');
            }
        }

        function setHDR(button, value) {
            button.parentElement.querySelectorAll('.hdr-btn').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            currentHDR = value;
        }

        function setGameHDR(id, value) {
            const game = [...games.shame, ...games.wishlist, ...games.completed].find(g => g.id === id);
            if (game) {
                game.hdr = value;
                saveData();
                renderTables();
            }
        }

        function setRating(type, rating) {
            if (type === 'add') {
                currentRating = rating;
                updateStarDisplay('addRating', rating);
            }
        }

        function setGameRating(id, rating) {
            const game = [...games.shame, ...games.wishlist, ...games.completed].find(g => g.id === id);
            if (game) {
                game.rating = rating;
                saveData();
                renderTables();
            }
        }

        function updateStarDisplay(elementId, rating) {
            const stars = document.getElementById(elementId).querySelectorAll('.star');
            stars.forEach((star, index) => {
                star.classList.toggle('filled', index < rating);
            });
        }

        document.getElementById('searchInput').addEventListener('input', function(e) {
            searchTerm = e.target.value.toLowerCase();
            renderTables();
        });

        function openCommentModal(gameIdOrType, comment, isEdit = false) {
            const modal = document.getElementById('commentModal');
            const overlay = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            const actions = document.getElementById('modalActions');
            const title = document.getElementById('modalTitle');
            
            if (gameIdOrType === 'add') {
                currentModalGameId = 'add';
                tempComment = document.getElementById('comment').value || '';
                title.textContent = 'Add Comment';
                currentModalMode = 'edit';
                
                content.innerHTML = `<textarea class="comment-modal-content editable">${tempComment}</textarea>`;
                actions.innerHTML = `
                    <button class="comment-modal-btn secondary" onclick="closeCommentModal()">Cancel</button>
                    <button class="comment-modal-btn primary" onclick="saveAddComment()">Save</button>
                `;
            } else {
                currentModalGameId = gameIdOrType;
                tempComment = comment || '';
                
                if (isEdit) {
                    title.textContent = 'Edit Comment';
                    currentModalMode = 'edit';
                    content.innerHTML = `<textarea class="comment-modal-content editable">${tempComment}</textarea>`;
                    actions.innerHTML = `
                        <button class="comment-modal-btn secondary" onclick="closeCommentModal()">Cancel</button>
                        <button class="comment-modal-btn primary" onclick="saveGameComment()">Save</button>
                    `;
                } else {
                    title.textContent = 'View Comment';
                    currentModalMode = 'view';
                    content.innerHTML = `<div class="comment-modal-content">${tempComment || 'No comment'}</div>`;
                    actions.innerHTML = `
                        <button class="comment-modal-btn secondary" onclick="closeCommentModal()">Close</button>
                        <button class="comment-modal-btn primary" onclick="editComment()">Edit</button>
                    `;
                }
            }
            
            modal.classList.add('active');
            overlay.classList.add('active');
        }

        function editComment() {
            const content = document.getElementById('modalContent');
            const actions = document.getElementById('modalActions');
            const title = document.getElementById('modalTitle');
            
            title.textContent = 'Edit Comment';
            currentModalMode = 'edit';
            content.innerHTML = `<textarea class="comment-modal-content editable">${tempComment}</textarea>`;
            actions.innerHTML = `
                <button class="comment-modal-btn secondary" onclick="closeCommentModal()">Cancel</button>
                <button class="comment-modal-btn primary" onclick="saveGameComment()">Save</button>
            `;
        }

        function saveAddComment() {
            const textarea = document.querySelector('.comment-modal-content.editable');
            document.getElementById('comment').value = textarea.value;
            closeCommentModal();
        }

        function saveGameComment() {
            const textarea = document.querySelector('.comment-modal-content.editable');
            updateGameField(currentModalGameId, 'comment', textarea.value);
            closeCommentModal();
        }

        function addGame() {
            const name = document.getElementById('gameName').value;
            const lengthMain = document.getElementById('lengthMain').value;
            const lengthExtra = document.getElementById('lengthExtra').value;
            const lengthComplete = document.getElementById('lengthComplete').value;
            const status = document.getElementById('statusDropdown').value;
            const difficulty = document.getElementById('difficulty').value;
            const platform = document.getElementById('platform').value;
            const genre = document.getElementById('genre').value;
            const cost = document.getElementById('cost').value;
            const playedHours = document.getElementById('playedHours').value;
            const comment = document.getElementById('comment').value;

            if (!name) {
                alert('Please enter a game name!');
                return;
            }

            const game = {
                id: Date.now(),
                name: name,
                lengthMain: lengthMain || 'N/A',
                lengthExtra: lengthExtra || 'N/A',
                lengthComplete: lengthComplete || 'N/A',
                status: status,
                difficulty: difficulty || 'Unknown',
                platform: platform || 'Unknown',
                genre: genre || 'Unknown',
                cost: parseFloat(cost) || 0,
                playedHours: parseFloat(playedHours) || 0,
                replayable: currentReplayable,
                coop: currentCoop,
                playingWith: currentPlayingWith.length > 0 ? currentPlayingWith : ['Solo'],
                hdr: currentHDR,
                rating: currentRating,
                comment: comment || '',
                completed: false
            };

            // Auto-set co-op if friends are selected
            if (currentPlayingWith.length > 1 || (currentPlayingWith.length === 1 && currentPlayingWith[0] !== 'Solo')) {
                game.coop = true;
                currentCoop = true;
                document.getElementById('coopBtn').classList.add('checked');
            }

            if (status === 'wishlist') {
                games.wishlist.push(game);
            } else {
                games.shame.push(game);
            }
            
            saveData();
            
            // Clear form
            document.getElementById('gameName').value = '';
            document.getElementById('lengthMain').value = '';
            document.getElementById('lengthExtra').value = '';
            document.getElementById('lengthComplete').value = '';
            document.getElementById('statusDropdown').value = 'none';
            document.getElementById('difficulty').value = 'Unknown';
            document.getElementById('difficulty').className = 'difficulty-select';
            document.getElementById('platform').value = '';
            document.getElementById('genre').value = '';
            document.getElementById('cost').value = '';
            document.getElementById('playedHours').value = '';
            document.getElementById('comment').value = '';
            document.getElementById('playingWith').value = 'Solo';
            
            currentReplayable = false;
            currentCoop = false;
            currentPlayingWith = ['Solo'];
            document.getElementById('replayableBtn').classList.remove('checked');
            document.getElementById('coopBtn').classList.remove('checked');
            
            currentHDR = 'None';
            currentRating = 0;
            document.querySelectorAll('.form-grid .hdr-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.form-grid .hdr-btn').classList.add('active');
            updateStarDisplay('addRating', 0);

            renderTables();
            updateTimeCalculation();
            updateTimeline();
            updateStatistics();
            checkWarnings();
        }

        function toggleGame(id) {
            let gameIndex = games.shame.findIndex(g => g.id === id);
            let fromList = 'shame';
            let toList = 'completed';

            if (gameIndex === -1) {
                gameIndex = games.completed.findIndex(g => g.id === id);
                fromList = 'completed';
                toList = 'shame';
            }

            if (gameIndex !== -1) {
                const game = games[fromList][gameIndex];
                game.completed = !game.completed;
                
                games[fromList].splice(gameIndex, 1);
                
                if (toList === 'shame') {
                    game.status = 'none';
                    game.completedDate = null;
                } else {
                    game.status = 'completed';
                    // Auto-assign completion date if not set
                    if (!game.completedDate) {
                        const today = new Date();
                        game.completedDate = today.toISOString().split('T')[0];
                    }
                }
                
                games[toList].push(game);
                saveData();
                renderTables();
                updateTimeCalculation();
                updateTimeline();
                updateStatistics();
            }
        }

        function moveToBacklog(id) {
            const gameIndex = games.wishlist.findIndex(g => g.id === id);
            if (gameIndex !== -1) {
                const game = games.wishlist[gameIndex];
                games.wishlist.splice(gameIndex, 1);
                game.status = 'none';
                games.shame.push(game);
                saveData();
                renderTables();
                updateTimeCalculation();
                updateTimeline();
                updateStatistics();
            }
        }

        function updateGameField(id, field, value) {
            const game = [...games.shame, ...games.wishlist, ...games.completed].find(g => g.id === id);
            if (game) {
                if (field === 'cost' || field === 'playedHours') {
                    game[field] = parseFloat(value) || 0;
                } else if (field === 'replayable' || field === 'coop') {
                    game[field] = value;
                } else {
                    game[field] = value;
                }
                saveData();
                renderTables();
                if (field === 'lengthMain' || field === 'lengthExtra' || field === 'playedHours' || field === 'status' || field === 'replayable') {
                    updateTimeCalculation();
                }
                updateTimeline();
                updateStatistics();
                checkWarnings();
            }
        }

        function deleteGame(id) {
            if (confirm('Are you sure you want to delete this game?')) {
                games.shame = games.shame.filter(g => g.id !== id);
                games.wishlist = games.wishlist.filter(g => g.id !== id);
                games.completed = games.completed.filter(g => g.id !== id);
                saveData();
                renderTables();
                updateTimeCalculation();
                updateTimeline();
                updateStatistics();
                checkWarnings();
            }
        }

        function calculateValue(cost, hours) {
            if (!hours || hours === 0) return '-';
            const value = cost / hours;
            return value.toFixed(2) + '€/h';
        }

        function getValueClass(value) {
            if (value === '-') return '';
            const numValue = parseFloat(value.toString().replace('€/h', ''));
            if (numValue <= 2) return 'value-high';
            if (numValue <= 5) return 'value-medium';
            return 'value-low';
        }

        function getRowClass(status) {
            switch(status) {
                case 'playing': return 'playing-row';
                case 'hold': return 'hold-row';
                case 'abandoned': return 'abandoned-row';
                case 'wishlist': return 'wishlist-row';
                default: return '';
            }
        }

        function handleDragStart(e, id) {
            draggedElement = id;
            e.target.parentElement.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.parentElement.classList.remove('dragging');
            // Remove all drag-target classes
            document.querySelectorAll('.drag-target').forEach(row => row.classList.remove('drag-target'));
            hideDragIndicator();
        }

        function handleDragOver(e) {
            e.preventDefault();
            const row = e.target.closest('tr');
            if (row && !row.classList.contains('dragging')) {
                // Remove previous targets
                document.querySelectorAll('.drag-target').forEach(r => r.classList.remove('drag-target'));
                // Add target class to current row
                row.classList.add('drag-target');
            }
        }

        function handleDrop(e, targetId, list) {
            e.preventDefault();
            
            // Remove all drag-target classes
            document.querySelectorAll('.drag-target').forEach(row => row.classList.remove('drag-target'));
            
            if (draggedElement && draggedElement !== targetId) {
                const draggedIndex = games[list].findIndex(g => g.id === draggedElement);
                const targetIndex = games[list].findIndex(g => g.id === targetId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    const draggedGame = games[list][draggedIndex];
                    const targetGame = games[list][targetIndex];
                    
                    if (list === 'shame' && draggedGame.status !== targetGame.status) {
                        draggedElement = null;
                        return;
                    }
                    
                    games[list].splice(draggedIndex, 1);
                    const newTargetIndex = games[list].findIndex(g => g.id === targetId);
                    const insertIndex = draggedIndex < targetIndex ? newTargetIndex + 1 : newTargetIndex;
                    games[list].splice(insertIndex, 0, draggedGame);
                    
                    saveData();
                    renderTables();
                    updateTimeCalculation();
                    updateTimeline();
                }
            }
            draggedElement = null;
        }

        function renderStars(id, rating) {
            let html = '<div class="star-rating">';
            for (let i = 1; i <= 5; i++) {
                html += `<span class="star ${rating >= i ? 'filled' : ''}" onclick="setGameRating(${id}, ${i})">★</span>`;
            }
            html += '</div>';
            return html;
        }

        function renderDifficulty(id, difficulty) {
            const selectedClass = difficulty === 'Easy' ? 'easy' : 
                                 difficulty === 'Medium' ? 'medium' : 
                                 difficulty === 'Hard' ? 'hard' : '';
            return `
                <select class="difficulty-select ${selectedClass}" 
                        onchange="updateGameField(${id}, 'difficulty', this.value); updateDifficultyStyle(this)">
                    <option value="Unknown" ${difficulty === 'Unknown' ? 'selected' : ''}>Unknown</option>
                    <option value="Easy" ${difficulty === 'Easy' ? 'selected' : ''}>Easy</option>
                    <option value="Medium" ${difficulty === 'Medium' ? 'selected' : ''}>Medium</option>
                    <option value="Hard" ${difficulty === 'Hard' ? 'selected' : ''}>Hard</option>
                </select>
            `;
        }

        function renderHDR(id, hdr) {
            return `
                <div class="hdr-buttons">
                    <button class="hdr-btn ${hdr === 'None' ? 'active' : ''}" onclick="setGameHDR(${id}, 'None')" title="None">✕</button>
                    <button class="hdr-btn ${hdr === 'Native' ? 'active' : ''}" onclick="setGameHDR(${id}, 'Native')" title="Native HDR">★</button>
                    <button class="hdr-btn ${hdr === 'AutoHDR' ? 'active' : ''}" onclick="setGameHDR(${id}, 'AutoHDR')" title="Auto HDR">◐</button>
                </div>
            `;
        }

        function exportToCSV() {
            const allGames = [...games.shame, ...games.wishlist, ...games.completed];
            if (allGames.length === 0) {
                alert('No games to export!');
                return;
            }

            const headers = ['List', 'Name', 'Main Story', 'Main+Extra', 'Completionist', 'Status', 'Difficulty', 'Platform', 'Genre', 'Cost', 'Played Hours', 'Replayable', 'Coop', 'Playing With', 'HDR', 'Rating', 'Comment', 'Completed Date'];
            const csvContent = [
                headers.join(','),
                ...allGames.map(game => {
                    const list = game.completed ? 'Completed' : 
                                game.status === 'wishlist' ? 'Wishlist' : 'Backlog';
                    const playingWith = game.playingWith ? game.playingWith.join('; ') : 'Solo';
                    return [
                        list,
                        `"${game.name.replace(/"/g, '""')}"`,
                        game.lengthMain,
                        game.lengthExtra,
                        game.lengthComplete,
                        game.status || 'none',
                        game.difficulty,
                        game.platform,
                        game.genre,
                        game.cost,
                        game.playedHours,
                        game.replayable ? 'Yes' : 'No',
                        game.coop ? 'Yes' : 'No',
                        `"${playingWith.replace(/"/g, '""')}"`,
                        game.hdr || 'None',
                        game.rating || 0,
                        `"${(game.comment || '').replace(/"/g, '""')}"`,
                        game.completedDate || ''
                    ].join(',');
                })
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `game-backlog-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvData = e.target.result;
                    const lines = csvData.split('\n');
                    
                    if (lines.length < 2) {
                        alert('CSV file appears to be empty or invalid.');
                        return;
                    }
                    
                    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                    const importedGames = [];
                    let errorCount = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        try {
                            // Parse CSV line properly handling quoted values
                            const values = parseCSVLine(line);
                            if (values.length < headers.length) continue;
                            
                            const gameData = {};
                            headers.forEach((header, index) => {
                                if (index < values.length) {
                                    gameData[header] = values[index];
                                }
                            });
                            
                            // Map CSV data to game object structure
                            const game = {
                                id: Date.now() + Math.random(),
                                name: gameData['Name'] || '',
                                lengthMain: parseFloat(gameData['Main Story']) || 0,
                                lengthExtra: parseFloat(gameData['Main+Extra']) || 0,
                                lengthComplete: parseFloat(gameData['Completionist']) || 0,
                                status: gameData['Status'] || 'none',
                                difficulty: gameData['Difficulty'] || 'Medium',
                                platform: gameData['Platform'] || 'Unknown',
                                genre: gameData['Genre'] || 'Unknown',
                                cost: parseFloat(gameData['Cost']) || 0,
                                playedHours: parseFloat(gameData['Played Hours']) || 0,
                                replayable: (gameData['Replayable'] || '').toLowerCase() === 'yes',
                                coop: (gameData['Coop'] || '').toLowerCase() === 'yes',
                                playingWith: gameData['Playing With'] && gameData['Playing With'] !== 'Solo' 
                                    ? gameData['Playing With'].split(';').map(f => f.trim()) 
                                    : ['Solo'],
                                hdr: gameData['HDR'] || 'None',
                                rating: parseInt(gameData['Rating']) || 0,
                                comment: gameData['Comment'] || '',
                                completedDate: gameData['Completed Date'] || '',
                                completed: (gameData['List'] || '').toLowerCase() === 'completed'
                            };
                            
                            if (game.name) {
                                importedGames.push(game);
                            }
                        } catch (err) {
                            errorCount++;
                            console.error(`Error parsing line ${i}:`, err);
                        }
                    }
                    
                    if (importedGames.length === 0) {
                        alert('No valid games found in CSV file.');
                        return;
                    }
                    
                    // Sort games into appropriate lists
                    let shameAdded = 0, wishlistAdded = 0, completedAdded = 0;
                    
                    importedGames.forEach(game => {
                        if (game.completed || game.status === 'completed') {
                            game.completed = true;
                            games.completed.push(game);
                            completedAdded++;
                        } else if (game.status === 'wishlist') {
                            games.wishlist.push(game);
                            wishlistAdded++;
                        } else {
                            games.shame.push(game);
                            shameAdded++;
                        }
                        
                        // Add unique friends from playing with field
                        if (game.playingWith) {
                            game.playingWith.forEach(friend => {
                                if (friend !== 'Solo' && !games.friends.includes(friend)) {
                                    games.friends.push(friend);
                                }
                            });
                        }
                    });
                    
                    // Update UI
                    renderTables();
                    updateTimeline();
                    updateStatistics();
                    updateWarnings();
                    trackChange();
                    
                    const message = `Import successful!\nAdded:\n${shameAdded} games to Backlog\n${wishlistAdded} games to Wishlist\n${completedAdded} games to Completed`;
                    if (errorCount > 0) {
                        alert(message + `\n\nNote: ${errorCount} lines had errors and were skipped.`);
                    } else {
                        alert(message);
                    }
                    
                } catch (error) {
                    console.error('Error importing CSV:', error);
                    alert('Error importing CSV file. Please check the file format.');
                }
            };
            
            reader.readAsText(file);
            event.target.value = '';
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i += 2;
                        continue;
                    }
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
                i++;
            }
            
            values.push(current.trim());
            return values;
        }

        function renderTables() {
            sortPileOfShame();

            const shameGames = games.shame || [];
            const wishlistGames = games.wishlist || [];
            const completedGames = games.completed || [];
            
            const filteredShame = filterGames(shameGames, 'shame');
            const filteredWishlist = filterGames(wishlistGames, 'wishlist');
            const filteredCompleted = filterGames(completedGames, 'completed');

            document.getElementById('shameCount').textContent = shameGames.length;
            document.getElementById('wishlistCount').textContent = wishlistGames.length;
            document.getElementById('completedCount').textContent = completedGames.length;

            calculateSummaries();

            // Render Pile of Shame
            const shameBody = document.getElementById('shameBody');
            const shameEmpty = document.getElementById('shameEmpty');
            
            if (shameGames.length === 0) {
                shameBody.innerHTML = '';
                shameEmpty.style.display = 'block';
                shameEmpty.textContent = 'No games in your backlog yet. Add some games above!';
            } else if (filteredShame.length === 0 && (searchTerm || Object.keys(activeFilters.shame).length > 0)) {
                shameBody.innerHTML = '';
                shameEmpty.style.display = 'block';
                shameEmpty.textContent = 'No games found matching your search/filters.';
            } else {
                shameEmpty.style.display = 'none';
                shameBody.innerHTML = filteredShame.map(game => {
                    const value = calculateValue(game.cost, game.playedHours);
                    const valueClass = getValueClass(value);
                    const rowClass = getRowClass(game.status);
                    const playingWith = game.playingWith || ['Solo'];
                    
                    return `
                    <tr class="${rowClass}" ondragover="handleDragOver(event)"
                        ondrop="handleDrop(event, ${game.id}, 'shame')">
                        <td class="drag-handle" 
                            draggable="true" 
                            ondragstart="handleDragStart(event, ${game.id})"
                            ondragend="handleDragEnd(event)">⋮</td>
                        <td class="checkbox-wrapper">
                            <input type="checkbox" class="checkbox" 
                                   onchange="toggleGame(${game.id})">
                        </td>
                        <td>
                            <input class="editable-field game-title" 
                                   value="${game.name}" 
                                   onchange="updateGameField(${game.id}, 'name', this.value)"
                                   onmouseover="showTooltip(event, '${game.name.replace(/'/g, "\\'")}')" 
                                   onmouseout="hideTooltip()">
                        </td>
                        <td><input class="editable-field length-cell" value="${game.lengthMain}" onchange="updateGameField(${game.id}, 'lengthMain', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthExtra}" onchange="updateGameField(${game.id}, 'lengthExtra', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthComplete}" onchange="updateGameField(${game.id}, 'lengthComplete', this.value)"></td>
                        <td>
                            <select class="status-select" onchange="changeGameStatus(${game.id}, this.value)">
                                <option value="none" ${game.status === 'none' || !game.status ? 'selected' : ''}>○ None</option>
                                <option value="playing" ${game.status === 'playing' ? 'selected' : ''}>▶ Playing</option>
                                <option value="hold" ${game.status === 'hold' ? 'selected' : ''}>⏸ On Hold</option>
                                <option value="abandoned" ${game.status === 'abandoned' ? 'selected' : ''}>❌ Abandoned</option>
                                <option value="wishlist" ${game.status === 'wishlist' ? 'selected' : ''}>💫 Wishlist</option>
                            </select>
                        </td>
                        <td class="infinity-cell ${game.replayable ? 'active' : ''}">
                            <input type="checkbox" class="checkbox" 
                                   ${game.replayable ? 'checked' : ''} 
                                   onchange="updateGameField(${game.id}, 'replayable', this.checked)"
                                   title="Infinitely Replayable">
                        </td>
                        <td class="coop-cell ${game.coop ? 'active' : ''}">
                            <input type="checkbox" class="checkbox" 
                                   ${game.coop ? 'checked' : ''} 
                                   onchange="updateGameField(${game.id}, 'coop', this.checked)"
                                   title="Co-op Game">
                        </td>
                        <td>${renderDifficulty(game.id, game.difficulty)}</td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'platform', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${platforms.map(p => `<option value="${p}" ${game.platform === p ? 'selected' : ''}>${p}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'genre', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${genres.map(g => `<option value="${g}" ${game.genre === g ? 'selected' : ''}>${g}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <input type="number" class="editable-field" 
                                   value="${game.cost}" step="0.01"
                                   onchange="updateGameField(${game.id}, 'cost', this.value)"
                                   placeholder="0">
                        </td>
                        <td>
                            <input type="number" class="editable-field" 
                                   value="${game.playedHours}" step="0.1"
                                   onchange="updateGameField(${game.id}, 'playedHours', this.value)"
                                   placeholder="0">
                        </td>
                        <td class="value-cell ${valueClass}">
                            ${value}
                        </td>
                        <td>${renderHDR(game.id, game.hdr || 'None')}</td>
                        <td>${renderStars(game.id, game.rating || 0)}</td>
                        <td>
                            <div class="playing-with-field">
                                <input class="editable-field" 
                                       value="${playingWith.join(', ')}" 
                                       onclick="openPlayingWithModal(${game.id})"
                                       onmouseover="showTooltip(event, '${playingWith.join(', ').replace(/'/g, "\\'")}')" 
                                       onmouseout="hideTooltip()"
                                       readonly>
                            </div>
                        </td>
                        <td>
                            <input class="editable-field comment-input" 
                                   value="${game.comment || ''}" 
                                   placeholder="Notes..."
                                   onclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}')"
                                   ondblclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}', true)"
                                   readonly>
                        </td>
                        <td>
                            <button class="delete-btn" onclick="deleteGame(${game.id})">Delete</button>
                        </td>
                    </tr>
                `}).join('');
            }

            // Render Wishlist
            const wishlistBody = document.getElementById('wishlistBody');
            const wishlistEmpty = document.getElementById('wishlistEmpty');
            
            if (wishlistGames.length === 0) {
                wishlistBody.innerHTML = '';
                wishlistEmpty.style.display = 'block';
            } else if (filteredWishlist.length === 0 && (searchTerm || Object.keys(activeFilters.wishlist).length > 0)) {
                wishlistBody.innerHTML = '';
                wishlistEmpty.style.display = 'block';
                wishlistEmpty.textContent = 'No wishlist games found matching your search/filters.';
            } else {
                wishlistEmpty.style.display = 'none';
                wishlistBody.innerHTML = filteredWishlist.map(game => {
                    return `
                    <tr class="wishlist-row">
                        <td>
                            <button class="control-btn" style="padding: 5px 10px; font-size: 11px;" 
                                    onclick="moveToBacklog(${game.id})">→ Backlog</button>
                        </td>
                        <td>
                            <input class="editable-field game-title" 
                                   value="${game.name}" 
                                   onchange="updateGameField(${game.id}, 'name', this.value)"
                                   onmouseover="showTooltip(event, '${game.name.replace(/'/g, "\\'")}')" 
                                   onmouseout="hideTooltip()">
                        </td>
                        <td><input class="editable-field length-cell" value="${game.lengthMain}" onchange="updateGameField(${game.id}, 'lengthMain', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthExtra}" onchange="updateGameField(${game.id}, 'lengthExtra', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthComplete}" onchange="updateGameField(${game.id}, 'lengthComplete', this.value)"></td>
                        <td>${renderDifficulty(game.id, game.difficulty)}</td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'platform', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${platforms.map(p => `<option value="${p}" ${game.platform === p ? 'selected' : ''}>${p}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'genre', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${genres.map(g => `<option value="${g}" ${game.genre === g ? 'selected' : ''}>${g}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <input type="number" class="editable-field" 
                                   value="${game.cost}" step="0.01"
                                   onchange="updateGameField(${game.id}, 'cost', this.value)"
                                   placeholder="0">
                        </td>
                        <td>${renderHDR(game.id, game.hdr || 'None')}</td>
                        <td>${renderStars(game.id, game.rating || 0)}</td>
                        <td>
                            <input class="editable-field comment-input" 
                                   value="${game.comment || ''}" 
                                   placeholder="Notes..."
                                   onclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}')"
                                   ondblclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}', true)"
                                   readonly>
                        </td>
                        <td>
                            <button class="delete-btn" onclick="deleteGame(${game.id})">Delete</button>
                        </td>
                    </tr>
                `}).join('');
            }

            // Render Completed
            const completedBody = document.getElementById('completedBody');
            const completedEmpty = document.getElementById('completedEmpty');
            
            if (completedGames.length === 0) {
                completedBody.innerHTML = '';
                completedEmpty.style.display = 'block';
            } else if (filteredCompleted.length === 0 && (searchTerm || Object.keys(activeFilters.completed).length > 0)) {
                completedBody.innerHTML = '';
                completedEmpty.style.display = 'block';
                completedEmpty.textContent = 'No completed games found matching your search/filters.';
            } else {
                completedEmpty.style.display = 'none';
                completedBody.innerHTML = filteredCompleted.map(game => {
                    const value = calculateValue(game.cost, game.playedHours);
                    const valueClass = getValueClass(value);
                    const config = statusConfig['completed'];
                    const playingWith = game.playingWith || ['Solo'];
                    
                    return `
                    <tr>
                        <td style="width: 35px;"></td>
                        <td class="checkbox-wrapper">
                            <input type="checkbox" class="checkbox" checked
                                   onchange="toggleGame(${game.id})">
                        </td>
                        <td>
                            <input class="editable-field game-title" 
                                   value="${game.name}" 
                                   onchange="updateGameField(${game.id}, 'name', this.value)"
                                   onmouseover="showTooltip(event, '${game.name.replace(/'/g, "\\'")}')" 
                                   onmouseout="hideTooltip()">
                        </td>
                        <td><input class="editable-field length-cell" value="${game.lengthMain}" onchange="updateGameField(${game.id}, 'lengthMain', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthExtra}" onchange="updateGameField(${game.id}, 'lengthExtra', this.value)"></td>
                        <td><input class="editable-field length-cell" value="${game.lengthComplete}" onchange="updateGameField(${game.id}, 'lengthComplete', this.value)"></td>
                        <td>
                            <input type="date" class="editable-field completed-date-field" 
                                   value="${game.completedDate || ''}" 
                                   onchange="updateGameField(${game.id}, 'completedDate', this.value)">
                        </td>
                        <td class="infinity-cell ${game.replayable ? 'active' : ''}">
                            <input type="checkbox" class="checkbox" 
                                   ${game.replayable ? 'checked' : ''} 
                                   onchange="updateGameField(${game.id}, 'replayable', this.checked)"
                                   title="Infinitely Replayable">
                        </td>
                        <td class="coop-cell ${game.coop ? 'active' : ''}">
                            <input type="checkbox" class="checkbox" 
                                   ${game.coop ? 'checked' : ''} 
                                   onchange="updateGameField(${game.id}, 'coop', this.checked)"
                                   title="Co-op Game">
                        </td>
                        <td>${renderDifficulty(game.id, game.difficulty)}</td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'platform', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${platforms.map(p => `<option value="${p}" ${game.platform === p ? 'selected' : ''}>${p}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <select class="editable-select" onchange="updateGameField(${game.id}, 'genre', this.value)">
                                <option value="Unknown">Unknown</option>
                                ${genres.map(g => `<option value="${g}" ${game.genre === g ? 'selected' : ''}>${g}</option>`).join('')}
                            </select>
                        </td>
                        <td>
                            <input type="number" class="editable-field" 
                                   value="${game.cost}" step="0.01"
                                   onchange="updateGameField(${game.id}, 'cost', this.value)"
                                   placeholder="0">
                        </td>
                        <td>
                            <input type="number" class="editable-field" 
                                   value="${game.playedHours}" step="0.1"
                                   onchange="updateGameField(${game.id}, 'playedHours', this.value)"
                                   placeholder="0">
                        </td>
                        <td class="value-cell ${valueClass}">
                            ${value}
                        </td>
                        <td>${renderHDR(game.id, game.hdr || 'None')}</td>
                        <td>${renderStars(game.id, game.rating || 0)}</td>
                        <td>
                            <div class="playing-with-field">
                                <input class="editable-field" 
                                       value="${playingWith.join(', ')}" 
                                       onclick="openPlayingWithModal(${game.id})"
                                       onmouseover="showTooltip(event, '${playingWith.join(', ').replace(/'/g, "\\'")}')" 
                                       onmouseout="hideTooltip()"
                                       readonly>
                            </div>
                        </td>
                        <td>
                            <input class="editable-field comment-input" 
                                   value="${game.comment || ''}" 
                                   placeholder="Notes..."
                                   onclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}')"
                                   ondblclick="openCommentModal(${game.id}, '${(game.comment || '').replace(/'/g, "\\'")}', true)"
                                   readonly>
                        </td>
                        <td>
                            <button class="delete-btn" onclick="deleteGame(${game.id})">Delete</button>
                        </td>
                    </tr>
                `}).join('');
            }
        }

        function initializeGenreDropdown() {
            const genreSelect = document.getElementById('genre');
            genreSelect.innerHTML = '<option value="">Select...</option>' + 
                genres.map(g => `<option value="${g}">${g}</option>`).join('');
            
            // Initialize filter genre dropdowns
            const filterGenreSelects = ['shameFilterGenre', 'wishlistFilterGenre', 'completedFilterGenre'];
            filterGenreSelects.forEach(id => {
                const select = document.getElementById(id);
                if (select) {
                    select.innerHTML = '<option value="">Any</option>' + 
                        genres.map(g => `<option value="${g}">${g}</option>`).join('');
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', function() {
            try {
                console.log('Initializing Enhanced Game Backlog Tracker...');
                initializeGenreDropdown();
                initSectionDragDrop();
                loadData();
                changesMade = false;
                
                const saveBtn = document.getElementById('saveBtn');
                if (saveBtn) {
                    saveBtn.classList.remove('unsaved');
                    saveBtn.innerHTML = '💾 Save HTML';
                }
                
                // Add cursor positioning for all editable fields
                addCursorPositioningToEditableFields();
                console.log('Initialization complete');
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        });

        // Function to position cursor at end of input fields
        function addCursorPositioningToEditableFields() {
            try {
                document.addEventListener('click', function(e) {
                    try {
                        if (e.target && e.target.classList && (e.target.classList.contains('editable-field') || e.target.classList.contains('game-title'))) {
                            // Skip cursor positioning if element has onclick attribute (like playing with modal)
                            if (e.target.hasAttribute('onclick')) {
                                return;
                            }
                            // Use setTimeout to ensure the field is focused first
                            setTimeout(() => {
                                try {
                                    const field = e.target;
                                    if (field && field.type && (field.type === 'text' || field.type === 'number' || field.tagName.toLowerCase() === 'textarea')) {
                                        const length = field.value ? field.value.length : 0;
                                        if (field.setSelectionRange) {
                                            field.setSelectionRange(length, length);
                                        }
                                    }
                                } catch (err) {
                                    console.log('Error in cursor positioning setTimeout:', err);
                                }
                            }, 0);
                        }
                    } catch (err) {
                        console.log('Error in click event handler:', err);
                    }
                });

                // Also handle focus events for programmatic focusing
                document.addEventListener('focus', function(e) {
                    try {
                        if (e.target && e.target.classList && (e.target.classList.contains('editable-field') || e.target.classList.contains('game-title'))) {
                            if (e.target.type === 'text' || e.target.type === 'number' || e.target.tagName.toLowerCase() === 'textarea') {
                                const length = e.target.value ? e.target.value.length : 0;
                                if (e.target.setSelectionRange) {
                                    e.target.setSelectionRange(length, length);
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Error in focus event handler:', err);
                    }
                }, true);
            } catch (err) {
                console.log('Error setting up cursor positioning:', err);
            }
        }
    </script>
</body>
</html>